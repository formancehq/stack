// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ReconciliationDetails The ReconciliationDetails object is attached to Transactions, Expected-Transactions and Payments. The data on the reconciliation object, will be identical on reconciled (paired) booked transactions and their underlying transactable (e.g. Payment or Expected-Transaction).
//
// swagger:model ReconciliationDetails
type ReconciliationDetails struct {

	// Populated if transactable is reconciled with a booked transaction. This field is also populated on booked transactions themselves (no matter if they are reconciled or not) and will always be the same id as the transaction's own id.
	// Example: e37235aa-adab-11ec-8029-96ac651c9332
	BookedTransactionID string `json:"bookedTransactionId,omitempty"`

	// Populated if booked transaction is reconciled with an underlying transactable. This field is also populated on expected transactions themselves (no matter if they are reconciled or not) and will always be the same id as the expected transaction's own id.
	// Example: a18ef4e2-bd24-42cc-af52-6ed3b93cdb45
	ExpectedTransactionID string `json:"expectedTransactionId,omitempty"`

	// The reconciliation status. Booked transactions can either be BOOKED (ie. not reconciled), or RECONCILED, while Expected Transactions or Payments can either be EXPECTED or RECONCILED.
	// Example: RECONCILED
	// Enum: [BOOKED EXPECTED RECONCILED]
	Status string `json:"status,omitempty"`

	// The id of the underlying transactable. Only populated for booked transactions if they are reconciled. For Payments and Expected Transactions, the transactableId will be the object's own id.
	// Example: 1d1a4c84-adac-11ec-b909-0242ac120002
	TransactableID string `json:"transactableId,omitempty"`

	// The type of the Transactable. This helps a client to know from where to fetch the transactable id (e.g. from payments endpoint or expected-transactions)
	// Example: PAYMENT
	// Enum: [PAYMENT EXPECTED_TRANSACTION]
	TransactableType string `json:"transactableType,omitempty"`
}

// Validate validates this reconciliation details
func (m *ReconciliationDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactableType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var reconciliationDetailsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BOOKED","EXPECTED","RECONCILED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reconciliationDetailsTypeStatusPropEnum = append(reconciliationDetailsTypeStatusPropEnum, v)
	}
}

const (

	// ReconciliationDetailsStatusBOOKED captures enum value "BOOKED"
	ReconciliationDetailsStatusBOOKED string = "BOOKED"

	// ReconciliationDetailsStatusEXPECTED captures enum value "EXPECTED"
	ReconciliationDetailsStatusEXPECTED string = "EXPECTED"

	// ReconciliationDetailsStatusRECONCILED captures enum value "RECONCILED"
	ReconciliationDetailsStatusRECONCILED string = "RECONCILED"
)

// prop value enum
func (m *ReconciliationDetails) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, reconciliationDetailsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ReconciliationDetails) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

var reconciliationDetailsTypeTransactableTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PAYMENT","EXPECTED_TRANSACTION"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reconciliationDetailsTypeTransactableTypePropEnum = append(reconciliationDetailsTypeTransactableTypePropEnum, v)
	}
}

const (

	// ReconciliationDetailsTransactableTypePAYMENT captures enum value "PAYMENT"
	ReconciliationDetailsTransactableTypePAYMENT string = "PAYMENT"

	// ReconciliationDetailsTransactableTypeEXPECTEDTRANSACTION captures enum value "EXPECTED_TRANSACTION"
	ReconciliationDetailsTransactableTypeEXPECTEDTRANSACTION string = "EXPECTED_TRANSACTION"
)

// prop value enum
func (m *ReconciliationDetails) validateTransactableTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, reconciliationDetailsTypeTransactableTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ReconciliationDetails) validateTransactableType(formats strfmt.Registry) error {
	if swag.IsZero(m.TransactableType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTransactableTypeEnum("transactableType", "body", m.TransactableType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this reconciliation details based on context it is used
func (m *ReconciliationDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ReconciliationDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ReconciliationDetails) UnmarshalBinary(b []byte) error {
	var res ReconciliationDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

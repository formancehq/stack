// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreatePaymentRequest create payment request
//
// swagger:model CreatePaymentRequest
type CreatePaymentRequest struct {

	// amount
	// Required: true
	Amount *AmountInput `json:"amount"`

	// ISO 20022 Category Purpose Code (ExternalCategoryPurpose1Code). Whether the category purpose code is
	// propagated and/or used throughout the complete chain of payment processing intermediaries and made available to the
	// creditor bank may be subject to bank and scheme specifics. Specifying category purpose is supported for
	// the following schemes: SCT, CROSS_BORDER.
	// Example: SALA
	CategoryPurpose string `json:"categoryPurpose,omitempty"`

	// This field specifies which party should bear the charges of the transaction.
	// If not specified, a default value will be used. This depends on the bank and the scheme, but typically
	// this means that the cost will be shared between the parties.
	// Example: SHARED
	// Enum: [SHARED DEBTOR CREDITOR]
	ChargeBearer string `json:"chargeBearer,omitempty"`

	// The requested execution date with format: `yyyy-mm-dd`. It is a local date from the source account's point-of-view, without timezone. Cannot be set to before the current date, and not more than 60 days into the future.
	// Example: 2022-05-07
	// Required: true
	Date *string `json:"date"`

	// The unique ID of the external destination account as found from /v1/external-accounts.
	// Example: bd8377bf-3eb7-44df-8638-203457afeedf
	// Required: true
	DestinationExternalAccountID *string `json:"destinationExternalAccountId"`

	// ExternalId is optional to use, but if used, the Atlar platform will persist it, index it, as well as require it to be unique. It is also possible to retrieve the identified resource using the ExternalId.
	// Example: walVNuin6X5Mvte4xhg1ibTAVSACfN4Q9hl
	ExternalID string `json:"externalId,omitempty"`

	// external metadata
	ExternalMetadata ExternalMetadata `json:"externalMetadata,omitempty"`

	// The payment scheme that is desired. Choose among SCT (SEPA Credit Transfer), SCT_INST (SEPA Instant Credit Transfer), GB_CT_BACS (UK account-to-account BACS), GB_CT_FPS (UK account-to-account Faster Payments), SE_A2A (Swedish account-to-account), SE_GIRO (Swedish Bank/Plus-giro), DK_A2A (Danish account-to-account), DK_CT_SAMEDAY (Danish same-day credit transfer), DK_CT_INST (Danish instant credit transfer),  CROSS_BORDER (swift).
	// Example: SCT
	// Required: true
	// Enum: [SCT SCT_INST GB_CT_BACS GB_CT_FPS SE_A2A SE_GIRO DK_A2A DK_CT_SAMEDAY DK_CT_INST CH_CT CROSS_BORDER]
	PaymentSchemeType *string `json:"paymentSchemeType"`

	// remittance information
	// Required: true
	RemittanceInformation *RemittanceInformation `json:"remittanceInformation"`

	// The unique ID of the source account as found from /v1/accounts
	// Example: 75c5b34c-e2b4-416b-9f23-8e797a620768
	// Required: true
	SourceAccountID *string `json:"sourceAccountId"`
}

// Validate validates this create payment request
func (m *CreatePaymentRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChargeBearer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestinationExternalAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentSchemeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemittanceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceAccountID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreatePaymentRequest) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amount")
			}
			return err
		}
	}

	return nil
}

var createPaymentRequestTypeChargeBearerPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SHARED","DEBTOR","CREDITOR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createPaymentRequestTypeChargeBearerPropEnum = append(createPaymentRequestTypeChargeBearerPropEnum, v)
	}
}

const (

	// CreatePaymentRequestChargeBearerSHARED captures enum value "SHARED"
	CreatePaymentRequestChargeBearerSHARED string = "SHARED"

	// CreatePaymentRequestChargeBearerDEBTOR captures enum value "DEBTOR"
	CreatePaymentRequestChargeBearerDEBTOR string = "DEBTOR"

	// CreatePaymentRequestChargeBearerCREDITOR captures enum value "CREDITOR"
	CreatePaymentRequestChargeBearerCREDITOR string = "CREDITOR"
)

// prop value enum
func (m *CreatePaymentRequest) validateChargeBearerEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createPaymentRequestTypeChargeBearerPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreatePaymentRequest) validateChargeBearer(formats strfmt.Registry) error {
	if swag.IsZero(m.ChargeBearer) { // not required
		return nil
	}

	// value enum
	if err := m.validateChargeBearerEnum("chargeBearer", "body", m.ChargeBearer); err != nil {
		return err
	}

	return nil
}

func (m *CreatePaymentRequest) validateDate(formats strfmt.Registry) error {

	if err := validate.Required("date", "body", m.Date); err != nil {
		return err
	}

	return nil
}

func (m *CreatePaymentRequest) validateDestinationExternalAccountID(formats strfmt.Registry) error {

	if err := validate.Required("destinationExternalAccountId", "body", m.DestinationExternalAccountID); err != nil {
		return err
	}

	return nil
}

func (m *CreatePaymentRequest) validateExternalMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalMetadata) { // not required
		return nil
	}

	if m.ExternalMetadata != nil {
		if err := m.ExternalMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("externalMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("externalMetadata")
			}
			return err
		}
	}

	return nil
}

var createPaymentRequestTypePaymentSchemeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SCT","SCT_INST","GB_CT_BACS","GB_CT_FPS","SE_A2A","SE_GIRO","DK_A2A","DK_CT_SAMEDAY","DK_CT_INST","CH_CT","CROSS_BORDER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createPaymentRequestTypePaymentSchemeTypePropEnum = append(createPaymentRequestTypePaymentSchemeTypePropEnum, v)
	}
}

const (

	// CreatePaymentRequestPaymentSchemeTypeSCT captures enum value "SCT"
	CreatePaymentRequestPaymentSchemeTypeSCT string = "SCT"

	// CreatePaymentRequestPaymentSchemeTypeSCTINST captures enum value "SCT_INST"
	CreatePaymentRequestPaymentSchemeTypeSCTINST string = "SCT_INST"

	// CreatePaymentRequestPaymentSchemeTypeGBCTBACS captures enum value "GB_CT_BACS"
	CreatePaymentRequestPaymentSchemeTypeGBCTBACS string = "GB_CT_BACS"

	// CreatePaymentRequestPaymentSchemeTypeGBCTFPS captures enum value "GB_CT_FPS"
	CreatePaymentRequestPaymentSchemeTypeGBCTFPS string = "GB_CT_FPS"

	// CreatePaymentRequestPaymentSchemeTypeSEA2A captures enum value "SE_A2A"
	CreatePaymentRequestPaymentSchemeTypeSEA2A string = "SE_A2A"

	// CreatePaymentRequestPaymentSchemeTypeSEGIRO captures enum value "SE_GIRO"
	CreatePaymentRequestPaymentSchemeTypeSEGIRO string = "SE_GIRO"

	// CreatePaymentRequestPaymentSchemeTypeDKA2A captures enum value "DK_A2A"
	CreatePaymentRequestPaymentSchemeTypeDKA2A string = "DK_A2A"

	// CreatePaymentRequestPaymentSchemeTypeDKCTSAMEDAY captures enum value "DK_CT_SAMEDAY"
	CreatePaymentRequestPaymentSchemeTypeDKCTSAMEDAY string = "DK_CT_SAMEDAY"

	// CreatePaymentRequestPaymentSchemeTypeDKCTINST captures enum value "DK_CT_INST"
	CreatePaymentRequestPaymentSchemeTypeDKCTINST string = "DK_CT_INST"

	// CreatePaymentRequestPaymentSchemeTypeCHCT captures enum value "CH_CT"
	CreatePaymentRequestPaymentSchemeTypeCHCT string = "CH_CT"

	// CreatePaymentRequestPaymentSchemeTypeCROSSBORDER captures enum value "CROSS_BORDER"
	CreatePaymentRequestPaymentSchemeTypeCROSSBORDER string = "CROSS_BORDER"
)

// prop value enum
func (m *CreatePaymentRequest) validatePaymentSchemeTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createPaymentRequestTypePaymentSchemeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreatePaymentRequest) validatePaymentSchemeType(formats strfmt.Registry) error {

	if err := validate.Required("paymentSchemeType", "body", m.PaymentSchemeType); err != nil {
		return err
	}

	// value enum
	if err := m.validatePaymentSchemeTypeEnum("paymentSchemeType", "body", *m.PaymentSchemeType); err != nil {
		return err
	}

	return nil
}

func (m *CreatePaymentRequest) validateRemittanceInformation(formats strfmt.Registry) error {

	if err := validate.Required("remittanceInformation", "body", m.RemittanceInformation); err != nil {
		return err
	}

	if m.RemittanceInformation != nil {
		if err := m.RemittanceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remittanceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remittanceInformation")
			}
			return err
		}
	}

	return nil
}

func (m *CreatePaymentRequest) validateSourceAccountID(formats strfmt.Registry) error {

	if err := validate.Required("sourceAccountId", "body", m.SourceAccountID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment request based on the context it is used
func (m *CreatePaymentRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemittanceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreatePaymentRequest) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {

		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amount")
			}
			return err
		}
	}

	return nil
}

func (m *CreatePaymentRequest) contextValidateExternalMetadata(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.ExternalMetadata) { // not required
		return nil
	}

	if err := m.ExternalMetadata.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("externalMetadata")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("externalMetadata")
		}
		return err
	}

	return nil
}

func (m *CreatePaymentRequest) contextValidateRemittanceInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.RemittanceInformation != nil {

		if err := m.RemittanceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remittanceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remittanceInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreatePaymentRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreatePaymentRequest) UnmarshalBinary(b []byte) error {
	var res CreatePaymentRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

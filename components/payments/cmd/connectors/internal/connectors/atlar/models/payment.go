// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Payment payment
//
// swagger:model Payment
type Payment struct {

	// amount
	Amount *Amount `json:"amount,omitempty"`

	// approval chain
	ApprovalChain *PaymentApprovalChain `json:"approvalChain,omitempty"`

	// attached transactions
	AttachedTransactions []*AttachedTransaction `json:"attachedTransactions"`

	// ISO 20022 Category Purpose Code (ExternalCategoryPurpose1Code).
	// Example: SALA
	CategoryPurpose string `json:"categoryPurpose,omitempty"`

	// This field specifies which party should bear the charges of the transaction.
	// Example: SHARED
	// Enum: [SHARED DEBTOR CREDITOR]
	ChargeBearer string `json:"chargeBearer,omitempty"`

	// The ID of the instruction that was sent to the bank where this credit transfer was included when it was created.
	// Example: c1d6502c-07c7-4c77-bee5-963f9464c7d8
	ConnectionInstructionID string `json:"connectionInstructionId,omitempty"`

	// created
	Created string `json:"created,omitempty"`

	// yyyy-mm-dd local date, no timezone
	// Example: 2022-05-07
	Date string `json:"date,omitempty"`

	// destination counterparty
	DestinationCounterparty *CounterpartySlim `json:"destinationCounterparty,omitempty"`

	// destination external account
	DestinationExternalAccount *ExternalAccountSlim `json:"destinationExternalAccount,omitempty"`

	// The ETag based on version. To be passed along in `If-Match` header when updating a CreditTransfer
	// Example: version:1
	Etag string `json:"etag,omitempty"`

	// ExternalId is optional to use, but if used, the Atlar platform will persist it, index it, as well as require it to be unique. It is also possible to retrieve the identified resource using the ExternalId.
	// Example: walVNuin6X5Mvte4xhg1ibTAVSACfN4Q9hl
	ExternalID string `json:"externalId,omitempty"`

	// external metadata
	ExternalMetadata ExternalMetadata `json:"externalMetadata,omitempty"`

	// id
	// Example: 76992987-48fc-4b03-b609-ea6fdc3045b4
	ID string `json:"id,omitempty"`

	// organization Id
	// Example: 605e26fc-4fce-495a-a92f-2c3592d7287e
	OrganizationID string `json:"organizationId,omitempty"`

	// payment scheme
	PaymentScheme *PaymentScheme `json:"paymentScheme,omitempty"`

	// payment scheme type
	PaymentSchemeType string `json:"paymentSchemeType,omitempty"`

	// reconciliation
	Reconciliation *ReconciliationDetails `json:"reconciliation,omitempty"`

	// remittance information
	RemittanceInformation *RemittanceInformation `json:"remittanceInformation,omitempty"`

	// source account
	SourceAccount *AccountSlim `json:"sourceAccount,omitempty"`

	// status
	// Example: SENT
	// Enum: [CREATED APPROVED REJECTED PENDING_SUBMISSION SENT PENDING_AT_BANK ACCEPTED EXECUTED FAILED RECONCILED RETURNED]
	Status string `json:"status,omitempty"`

	// starts at 1 when the Credit Transfer is created and increases by one in each successive update
	// Example: 1
	Version int64 `json:"version,omitempty"`
}

// Validate validates this payment
func (m *Payment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApprovalChain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttachedTransactions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChargeBearer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestinationCounterparty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestinationExternalAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReconciliation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemittanceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(m.Amount) { // not required
		return nil
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amount")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateApprovalChain(formats strfmt.Registry) error {
	if swag.IsZero(m.ApprovalChain) { // not required
		return nil
	}

	if m.ApprovalChain != nil {
		if err := m.ApprovalChain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("approvalChain")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("approvalChain")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateAttachedTransactions(formats strfmt.Registry) error {
	if swag.IsZero(m.AttachedTransactions) { // not required
		return nil
	}

	for i := 0; i < len(m.AttachedTransactions); i++ {
		if swag.IsZero(m.AttachedTransactions[i]) { // not required
			continue
		}

		if m.AttachedTransactions[i] != nil {
			if err := m.AttachedTransactions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attachedTransactions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attachedTransactions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var paymentTypeChargeBearerPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SHARED","DEBTOR","CREDITOR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		paymentTypeChargeBearerPropEnum = append(paymentTypeChargeBearerPropEnum, v)
	}
}

const (

	// PaymentChargeBearerSHARED captures enum value "SHARED"
	PaymentChargeBearerSHARED string = "SHARED"

	// PaymentChargeBearerDEBTOR captures enum value "DEBTOR"
	PaymentChargeBearerDEBTOR string = "DEBTOR"

	// PaymentChargeBearerCREDITOR captures enum value "CREDITOR"
	PaymentChargeBearerCREDITOR string = "CREDITOR"
)

// prop value enum
func (m *Payment) validateChargeBearerEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, paymentTypeChargeBearerPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Payment) validateChargeBearer(formats strfmt.Registry) error {
	if swag.IsZero(m.ChargeBearer) { // not required
		return nil
	}

	// value enum
	if err := m.validateChargeBearerEnum("chargeBearer", "body", m.ChargeBearer); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateDestinationCounterparty(formats strfmt.Registry) error {
	if swag.IsZero(m.DestinationCounterparty) { // not required
		return nil
	}

	if m.DestinationCounterparty != nil {
		if err := m.DestinationCounterparty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destinationCounterparty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destinationCounterparty")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateDestinationExternalAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.DestinationExternalAccount) { // not required
		return nil
	}

	if m.DestinationExternalAccount != nil {
		if err := m.DestinationExternalAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destinationExternalAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destinationExternalAccount")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateExternalMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalMetadata) { // not required
		return nil
	}

	if m.ExternalMetadata != nil {
		if err := m.ExternalMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("externalMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("externalMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validatePaymentScheme(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentScheme) { // not required
		return nil
	}

	if m.PaymentScheme != nil {
		if err := m.PaymentScheme.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paymentScheme")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("paymentScheme")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateReconciliation(formats strfmt.Registry) error {
	if swag.IsZero(m.Reconciliation) { // not required
		return nil
	}

	if m.Reconciliation != nil {
		if err := m.Reconciliation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reconciliation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("reconciliation")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateRemittanceInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.RemittanceInformation) { // not required
		return nil
	}

	if m.RemittanceInformation != nil {
		if err := m.RemittanceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remittanceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remittanceInformation")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateSourceAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceAccount) { // not required
		return nil
	}

	if m.SourceAccount != nil {
		if err := m.SourceAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceAccount")
			}
			return err
		}
	}

	return nil
}

var paymentTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CREATED","APPROVED","REJECTED","PENDING_SUBMISSION","SENT","PENDING_AT_BANK","ACCEPTED","EXECUTED","FAILED","RECONCILED","RETURNED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		paymentTypeStatusPropEnum = append(paymentTypeStatusPropEnum, v)
	}
}

const (

	// PaymentStatusCREATED captures enum value "CREATED"
	PaymentStatusCREATED string = "CREATED"

	// PaymentStatusAPPROVED captures enum value "APPROVED"
	PaymentStatusAPPROVED string = "APPROVED"

	// PaymentStatusREJECTED captures enum value "REJECTED"
	PaymentStatusREJECTED string = "REJECTED"

	// PaymentStatusPENDINGSUBMISSION captures enum value "PENDING_SUBMISSION"
	PaymentStatusPENDINGSUBMISSION string = "PENDING_SUBMISSION"

	// PaymentStatusSENT captures enum value "SENT"
	PaymentStatusSENT string = "SENT"

	// PaymentStatusPENDINGATBANK captures enum value "PENDING_AT_BANK"
	PaymentStatusPENDINGATBANK string = "PENDING_AT_BANK"

	// PaymentStatusACCEPTED captures enum value "ACCEPTED"
	PaymentStatusACCEPTED string = "ACCEPTED"

	// PaymentStatusEXECUTED captures enum value "EXECUTED"
	PaymentStatusEXECUTED string = "EXECUTED"

	// PaymentStatusFAILED captures enum value "FAILED"
	PaymentStatusFAILED string = "FAILED"

	// PaymentStatusRECONCILED captures enum value "RECONCILED"
	PaymentStatusRECONCILED string = "RECONCILED"

	// PaymentStatusRETURNED captures enum value "RETURNED"
	PaymentStatusRETURNED string = "RETURNED"
)

// prop value enum
func (m *Payment) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, paymentTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Payment) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this payment based on the context it is used
func (m *Payment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateApprovalChain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAttachedTransactions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDestinationCounterparty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDestinationExternalAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaymentScheme(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReconciliation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemittanceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {

		if swag.IsZero(m.Amount) { // not required
			return nil
		}

		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amount")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateApprovalChain(ctx context.Context, formats strfmt.Registry) error {

	if m.ApprovalChain != nil {

		if swag.IsZero(m.ApprovalChain) { // not required
			return nil
		}

		if err := m.ApprovalChain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("approvalChain")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("approvalChain")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateAttachedTransactions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AttachedTransactions); i++ {

		if m.AttachedTransactions[i] != nil {

			if swag.IsZero(m.AttachedTransactions[i]) { // not required
				return nil
			}

			if err := m.AttachedTransactions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attachedTransactions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attachedTransactions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) contextValidateDestinationCounterparty(ctx context.Context, formats strfmt.Registry) error {

	if m.DestinationCounterparty != nil {

		if swag.IsZero(m.DestinationCounterparty) { // not required
			return nil
		}

		if err := m.DestinationCounterparty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destinationCounterparty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destinationCounterparty")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateDestinationExternalAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.DestinationExternalAccount != nil {

		if swag.IsZero(m.DestinationExternalAccount) { // not required
			return nil
		}

		if err := m.DestinationExternalAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destinationExternalAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destinationExternalAccount")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateExternalMetadata(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.ExternalMetadata) { // not required
		return nil
	}

	if err := m.ExternalMetadata.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("externalMetadata")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("externalMetadata")
		}
		return err
	}

	return nil
}

func (m *Payment) contextValidatePaymentScheme(ctx context.Context, formats strfmt.Registry) error {

	if m.PaymentScheme != nil {

		if swag.IsZero(m.PaymentScheme) { // not required
			return nil
		}

		if err := m.PaymentScheme.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paymentScheme")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("paymentScheme")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateReconciliation(ctx context.Context, formats strfmt.Registry) error {

	if m.Reconciliation != nil {

		if swag.IsZero(m.Reconciliation) { // not required
			return nil
		}

		if err := m.Reconciliation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reconciliation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("reconciliation")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateRemittanceInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.RemittanceInformation != nil {

		if swag.IsZero(m.RemittanceInformation) { // not required
			return nil
		}

		if err := m.RemittanceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remittanceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remittanceInformation")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateSourceAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.SourceAccount != nil {

		if swag.IsZero(m.SourceAccount) { // not required
			return nil
		}

		if err := m.SourceAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceAccount")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Payment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Payment) UnmarshalBinary(b []byte) error {
	var res Payment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

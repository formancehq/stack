// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateMandateRequest create mandate request
//
// swagger:model CreateMandateRequest
type CreateMandateRequest struct {

	// Set this to true if this mandate is already known by the bank. This is for example a good option if you're migrating a lot of mandates that you know are already active. The actual outcome of using this flag depends on the direct debit scheme, since all schemes work in slightly different ways. For example, for `AUTOGIRO`, it means that we won't send the mandate prior to making the collection. For other schemes, it could have an effect on how quickly the collection can be executed.
	// Example: false
	Active bool `json:"active,omitempty"`

	// The customer number that you have received from the bank. For `AUTOGIRO` this is your 6 digit customer number.
	// Example: creditor_id_123
	// Required: true
	// Max Length: 35
	// Min Length: 1
	CreditorReference *string `json:"creditorReference"`

	// The ID of the destination account where money will be collected for this mandate. This is only needed for `AUTOGIRO` mandates.
	// Example: 31d593d7-fff9-4783-aa1d-92acb7b21a19
	DestinationAccountID string `json:"destinationAccountId,omitempty"`

	// The scheme type of the direct debits for which this mandate will be used.
	// Example: SDD_CORE
	// Required: true
	// Enum: [SDD_CORE SDD_B2B AUTOGIRO]
	DirectDebitSchemeType *string `json:"directDebitSchemeType"`

	// The ID of the external account which you will make the direct debit collection from. External accounts can be created via the API.
	// Example: ba0ad236-2904-4b01-8e85-a4ef3a73c353
	// Required: true
	ExternalAccountID *string `json:"externalAccountId"`

	// ExternalId is optional to use, but if used, the Atlar platform will persist it, index it, as well as require it to be unique. It is also possible to retrieve the identified resource using the ExternalId.
	// Example: walVNuin6X5Mvte4xhg1ibTAVSACfN4Q9hl
	ExternalID string `json:"externalId,omitempty"`

	// Any external metadata you want to attach, such as your own internal IDs.
	ExternalMetadata ExternalMetadata `json:"externalMetadata,omitempty"`

	// A unique reference to the mandate that you have signed with the debtor. For `AUTOGIRO` this is used as payer number associated with the mandate and validated as 1-16 digits.
	// Example: mandate_id_123
	// Required: true
	// Max Length: 35
	// Min Length: 1
	MandateReference *string `json:"mandateReference"`

	// The national identifier of the debtor. This cannot be changed after the mandate has been created.
	NationalIdentifier *NationalIdentifier `json:"nationalIdentifier,omitempty"`

	// The date that this mandate was signed by the end user. Only required for `SDD_CORE`.
	// Example: 2022-08-01
	SignatureDate string `json:"signatureDate,omitempty"`
}

// Validate validates this create mandate request
func (m *CreateMandateRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreditorReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectDebitSchemeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMandateReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNationalIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateMandateRequest) validateCreditorReference(formats strfmt.Registry) error {

	if err := validate.Required("creditorReference", "body", m.CreditorReference); err != nil {
		return err
	}

	if err := validate.MinLength("creditorReference", "body", *m.CreditorReference, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("creditorReference", "body", *m.CreditorReference, 35); err != nil {
		return err
	}

	return nil
}

var createMandateRequestTypeDirectDebitSchemeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SDD_CORE","SDD_B2B","AUTOGIRO"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createMandateRequestTypeDirectDebitSchemeTypePropEnum = append(createMandateRequestTypeDirectDebitSchemeTypePropEnum, v)
	}
}

const (

	// CreateMandateRequestDirectDebitSchemeTypeSDDCORE captures enum value "SDD_CORE"
	CreateMandateRequestDirectDebitSchemeTypeSDDCORE string = "SDD_CORE"

	// CreateMandateRequestDirectDebitSchemeTypeSDDB2B captures enum value "SDD_B2B"
	CreateMandateRequestDirectDebitSchemeTypeSDDB2B string = "SDD_B2B"

	// CreateMandateRequestDirectDebitSchemeTypeAUTOGIRO captures enum value "AUTOGIRO"
	CreateMandateRequestDirectDebitSchemeTypeAUTOGIRO string = "AUTOGIRO"
)

// prop value enum
func (m *CreateMandateRequest) validateDirectDebitSchemeTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createMandateRequestTypeDirectDebitSchemeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateMandateRequest) validateDirectDebitSchemeType(formats strfmt.Registry) error {

	if err := validate.Required("directDebitSchemeType", "body", m.DirectDebitSchemeType); err != nil {
		return err
	}

	// value enum
	if err := m.validateDirectDebitSchemeTypeEnum("directDebitSchemeType", "body", *m.DirectDebitSchemeType); err != nil {
		return err
	}

	return nil
}

func (m *CreateMandateRequest) validateExternalAccountID(formats strfmt.Registry) error {

	if err := validate.Required("externalAccountId", "body", m.ExternalAccountID); err != nil {
		return err
	}

	return nil
}

func (m *CreateMandateRequest) validateExternalMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalMetadata) { // not required
		return nil
	}

	if m.ExternalMetadata != nil {
		if err := m.ExternalMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("externalMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("externalMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CreateMandateRequest) validateMandateReference(formats strfmt.Registry) error {

	if err := validate.Required("mandateReference", "body", m.MandateReference); err != nil {
		return err
	}

	if err := validate.MinLength("mandateReference", "body", *m.MandateReference, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("mandateReference", "body", *m.MandateReference, 35); err != nil {
		return err
	}

	return nil
}

func (m *CreateMandateRequest) validateNationalIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(m.NationalIdentifier) { // not required
		return nil
	}

	if m.NationalIdentifier != nil {
		if err := m.NationalIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nationalIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nationalIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create mandate request based on the context it is used
func (m *CreateMandateRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExternalMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNationalIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateMandateRequest) contextValidateExternalMetadata(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.ExternalMetadata) { // not required
		return nil
	}

	if err := m.ExternalMetadata.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("externalMetadata")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("externalMetadata")
		}
		return err
	}

	return nil
}

func (m *CreateMandateRequest) contextValidateNationalIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if m.NationalIdentifier != nil {

		if swag.IsZero(m.NationalIdentifier) { // not required
			return nil
		}

		if err := m.NationalIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nationalIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nationalIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateMandateRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateMandateRequest) UnmarshalBinary(b []byte) error {
	var res CreateMandateRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

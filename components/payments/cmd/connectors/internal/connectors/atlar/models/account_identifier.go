// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AccountIdentifier account identifier
//
// swagger:model AccountIdentifier
type AccountIdentifier struct {

	// The legal name of the individual or company holding the account
	// Example: John Smith
	// Required: true
	HolderName *string `json:"holderName"`

	// ISO3166 Alpha2 country code
	// Example: DE
	// Required: true
	Market *string `json:"market"`

	// The unformatted identifier itself. For BBAN type the number is country-specific.
	// Example: DE47500105175557488443
	// Required: true
	Number *string `json:"number"`

	// Type of the identifier. For country specific basic bank account number with bank identifier (e.g. routing or clearing number) choose BBAN. For country specific bank account number without bank identifier (e.g. routing or clearing number) choose ACCOUNT_NUMBER. For further information please refer to Account Identifiers section.
	// Example: IBAN
	// Required: true
	// Enum: [IBAN BBAN ACCOUNT_NUMBER SE_BG SE_PG]
	Type *string `json:"type"`
}

// Validate validates this account identifier
func (m *AccountIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHolderName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarket(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountIdentifier) validateHolderName(formats strfmt.Registry) error {

	if err := validate.Required("holderName", "body", m.HolderName); err != nil {
		return err
	}

	return nil
}

func (m *AccountIdentifier) validateMarket(formats strfmt.Registry) error {

	if err := validate.Required("market", "body", m.Market); err != nil {
		return err
	}

	return nil
}

func (m *AccountIdentifier) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("number", "body", m.Number); err != nil {
		return err
	}

	return nil
}

var accountIdentifierTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["IBAN","BBAN","ACCOUNT_NUMBER","SE_BG","SE_PG"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountIdentifierTypeTypePropEnum = append(accountIdentifierTypeTypePropEnum, v)
	}
}

const (

	// AccountIdentifierTypeIBAN captures enum value "IBAN"
	AccountIdentifierTypeIBAN string = "IBAN"

	// AccountIdentifierTypeBBAN captures enum value "BBAN"
	AccountIdentifierTypeBBAN string = "BBAN"

	// AccountIdentifierTypeACCOUNTNUMBER captures enum value "ACCOUNT_NUMBER"
	AccountIdentifierTypeACCOUNTNUMBER string = "ACCOUNT_NUMBER"

	// AccountIdentifierTypeSEBG captures enum value "SE_BG"
	AccountIdentifierTypeSEBG string = "SE_BG"

	// AccountIdentifierTypeSEPG captures enum value "SE_PG"
	AccountIdentifierTypeSEPG string = "SE_PG"
)

// prop value enum
func (m *AccountIdentifier) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountIdentifierTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountIdentifier) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account identifier based on context it is used
func (m *AccountIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountIdentifier) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountIdentifier) UnmarshalBinary(b []byte) error {
	var res AccountIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

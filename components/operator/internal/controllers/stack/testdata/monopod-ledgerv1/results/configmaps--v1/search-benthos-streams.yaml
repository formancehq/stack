apiVersion: v1
data:
    ledger_ingestion.yaml: "input:\n  event_bus:\n    topic: ledger\n    consumer_group: search\n\npipeline:\n  processors:\n  - switch_event_type:\n      events:\n      - label: COMMITTED_TRANSACTIONS\n        processors:\n        - bloblang: |\n            map account {\n              root = this.map_each(v -> v.value.map_each(v2 -> {\n                \"action\": \"upsert\",\n                \"id\": v.key,\n                \"document\": {\n                  \"data\": {\n                    \"address\": v.key\n                  },\n                  \"indexed\": {\n                    \"address\": v.key\n                  },\n                  \"kind\": \"ACCOUNT\"\n                }\n              }).values()).values().flatten()\n            }\n\n            map tx {\n              root = {\n                \"action\": \"index\",\n                \"id\": \"%s\".format(this.txid),\n                \"document\": {\n                  \"data\": {\n                    \"postings\": this.postings,\n                    \"reference\": this.reference,\n                    \"txid\": this.txid,\n                    \"timestamp\": this.timestamp,\n                    \"metadata\": if this.metadata { this.metadata } else {{}}\n                  },\n                  \"indexed\": {\n                    \"reference\": this.reference,\n                    \"txid\": this.txid,\n                    \"timestamp\": this.timestamp,\n                    \"asset\": this.postings.map_each(p -> p.asset),\n                    \"source\": this.postings.map_each(p -> p.source),\n                    \"destination\": this.postings.map_each(p -> p.destination),\n                    \"amount\": this.postings.map_each(p -> if p.asset.contains(\"/\") {\n                      [\n                        p.amount,\n                        p.amount / if p.asset.split(\"/\").index(1).number(){ range(0, p.asset.split(\"/\").index(1).number()).fold(1, t -> t.tally * 10) } else { 1 } # amount / pow(10, decimal part of asset)\n                      ]\n                    } else { [ p.amount ] }).flatten().map_each(v -> \"%v\".format(v))\n                  },\n                  \"kind\": \"TRANSACTION\"\n                }\n              }\n            }\n\n            map committedTransactions {\n                root = [\n                    this.payload.transactions.map_each(t -> t.apply(\"tx\")).map_each(t -> t.assign({\n                        \"id\": \"TRANSACTION-%s-%s\".format(this.payload.ledger, t.id)\n                    })),\n                    this.payload.transactions.map_each(t -> t.postings.map_each(p -> [{\n                        \"action\": \"upsert\",\n                        \"id\": \"ACCOUNT-%s-%s\".format(this.payload.ledger, p.source),\n                        \"document\": {\n                            \"data\": {\n                                \"address\": p.source\n                            },\n                            \"indexed\": {\n                                \"address\": p.source\n                            },\n                            \"kind\": \"ACCOUNT\"\n                        }\n                    }, {\n                        \"action\": \"upsert\",\n                        \"id\": \"ACCOUNT-%s-%s\".format(this.payload.ledger, p.destination),\n                        \"document\": {\n                            \"data\": {\n                                \"address\": p.destination\n                            },\n                            \"indexed\": {\n                                \"address\": p.destination\n                            },\n                            \"kind\": \"ACCOUNT\"\n                        }\n                    }])).flatten().flatten()\n                ].flatten().map_each(t -> t.merge({\n                   \"document\": {\n                       \"when\": this.date,\n                       \"ledger\": this.payload.ledger,\n                       \"data\": {\n                           \"ledger\": this.payload.ledger\n                       },\n                       \"indexed\": {\n                           \"ledger\": this.payload.ledger\n                       }\n                   },\n               }))\n            }\n\n            root = this.apply(\"committedTransactions\")\n        - unarchive:\n            format: json_array\n      - label: SAVED_METADATA\n        processors:\n        - bloblang: |\n            root = this.payload.metadata.map_each(item -> {\n              \"script\": \"ctx._source.data.metadata[\\\"\" + item.key + \"\\\"]=\\\"\" + item.value + \"\\\"\",\n              \"action\": \"update\",\n              \"id\": \"%s-%s-%s\".format(this.payload.targetType, this.payload.ledger, this.payload.targetId),\n              \"upsert\": {\n                \"data\": { \n                  \"address\": this,\n                  \"metadata\": { item.key: item.value },\n                  \"ledger\": this.payload.ledger\n                },\n                \"indexed\": { \n                  \"address\": this,\n                  \"ledger\": this.payload.ledger\n                },\n                \"kind\": \"ACCOUNT\"\n              }\n            }).values()\n        - unarchive:\n            format: json_array\n\noutput:\n  resource: elasticsearch\n"
    ledger_reindex.yaml: |
        input:
          http_server:
            path: /

        output:
          broker:
            outputs:
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_volumes
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_transactions
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_accounts
    ledger_reindex_accounts.yaml: |
        input:
          http_server:
            path: /

        pipeline:
          processors:
          - bloblang: |
              meta ledger = this.ledger
              meta batchSize = 100
          - postgres_query:
              service: ledger
              query: 'select count(*) as accounts_count from "${! meta("ledger") }".accounts'
          - unarchive:
              format: json_array
          - bloblang: |
              meta loopCount = (this.accounts_count.number() / meta("batchSize").number()).ceil()
              meta loopIndex = 0
          - while:
              check: 'meta("loopIndex") < meta("loopCount")'
              processors:
              - postgres_query:
                  service: ledger
                  query: |
                    select address, metadata
                    from "${! meta("ledger") }".accounts
                    offset ${! meta("loopIndex").number() * meta("batchSize").number() }
                    limit ${! meta("batchSize") }
              - bloblang:
                  meta loopIndex = meta("loopIndex").number() + 1
              - unarchive:
                  format: json_array
              - bloblang: |
                  root = this.assign({
                    "metadata": this.metadata.parse_json()
                  })
              - bloblang: |
                  meta action = "upsert"
                  meta id = "ACCOUNT-%s-%d".format(meta("ledger"), this.address)
                  root = {
                    "data": {
                      "address": this.address,
                      "ledger": meta("ledger"),
                      "metadata": this.metadata
                    },
                    "indexed": {
                      "address": this.address,
                      "ledger": meta("ledger")
                    },
                    "kind": "ACCOUNT",
                    "ledger": meta("ledger")
                  }

        output:
          resource: elasticsearch
    ledger_reindex_all.yaml: |
        input:
          http_server:
            path: /

        pipeline:
          processors:
          - postgres_query:
              service: ledger
              query: 'select * from "_system".ledgers'
          - unarchive:
              format: json_array

        output:
          broker:
            outputs:
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex
    ledger_reindex_transactions.yaml: |
        input:
          http_server:
            path: /

        pipeline:
          processors:
          - bloblang: |
              meta ledger = this.ledger
              meta batchSize = 100
          - postgres_query:
              service: ledger
              query: 'select count(*) as transactions_count from "${! meta("ledger") }".transactions'
          - unarchive:
              format: json_array
          - bloblang: |
              meta loopCount = (this.transactions_count.number() / meta("batchSize").number()).ceil()
              meta loopIndex = 0
          - while:
              check: 'meta("loopIndex") < meta("loopCount")'
              processors:
              - postgres_query:
                  service: ledger
                  query: |
                    select id, timestamp, reference, metadata, postings
                    from "${! meta("ledger") }".transactions
                    offset ${! meta("loopIndex").number() * meta("batchSize").number() }
                    limit ${! meta("batchSize") }
              - bloblang:
                  meta loopIndex = meta("loopIndex").number() + 1
              - unarchive:
                  format: json_array
              - bloblang: |
                  root = this.assign({
                    "postings": this.postings.parse_json(),
                    "metadata": this.metadata.parse_json()
                  })
              - bloblang: |
                  meta action = "upsert"
                  meta id = "TRANSACTION-%s-%d".format(meta("ledger"), this.id)
                  root = {
                    "data": {
                      "postings": this.postings,
                      "reference": this.reference,
                      "txid": this.id,
                      "timestamp": this.timestamp,
                      "metadata": if this.metadata { this.metadata } else {{}},
                      "ledger": meta("ledger")
                    },
                    "indexed": {
                      "reference": this.reference,
                      "txid": this.id,
                      "timestamp": this.timestamp,
                      "asset": this.postings.map_each(p -> p.asset),
                      "source": this.postings.map_each(p -> p.source),
                      "destination": this.postings.map_each(p -> p.destination),
                      "amount": this.postings.map_each(p -> if p.asset.contains("/") {
                        [
                          p.amount,
                          p.amount / range(0, p.asset.split("/").index(1).number()).fold(1, t -> t.tally * 10) # amount / pow(10, decimal part of asset)
                        ]
                      } else { [ p.amount ] }).flatten().map_each(v -> "%v".format(v)),
                      "ledger": meta("ledger")
                    },
                    "kind": "TRANSACTION",
                    "ledger": meta("ledger")
                  }

        output:
          resource: elasticsearch
    ledger_reindex_volumes.yaml: |
        input:
          http_server:
            path: /

        pipeline:
          processors:
          - bloblang: |
              meta ledger = this.ledger
              meta batchSize = 100
          - postgres_query:
              service: ledger
              query: 'select count(*) as volumes_count from "${! meta("ledger") }".volumes'
          - unarchive:
              format: json_array
          - bloblang: |
              meta loopCount = (this.volumes_count.number() / meta("batchSize").number()).ceil()
              meta loopIndex = 0
          - while:
              check: 'meta("loopIndex") < meta("loopCount")'
              processors:
              - postgres_query:
                  service: ledger
                  query: |
                    select account, asset, input, output
                    from "${! meta("ledger") }".volumes
                    offset ${! meta("loopIndex").number() * meta("batchSize").number() }
                    limit ${! meta("batchSize") }
              - bloblang:
                  meta loopIndex = meta("loopIndex").number() + 1
              - unarchive:
                  format: json_array
              - bloblang: |
                  meta action = "upsert"
                  meta id = "ASSET-%s-%s-%s".format(meta("ledger"), this.account, this.asset)
                  root = {
                    "data": {
                      "name": this.asset,
                      "input": this.input,
                      "output": this.output,
                      "account": this.account,
                      "ledger": meta("ledger")
                    },
                    "indexed": {
                      "account": this.account,
                      "name": this.asset,
                      "ledger": meta("ledger")
                    },
                    "kind": "ASSET",
                    "ledger": meta("ledger")
                  }

        output:
          resource: elasticsearch
    payments_deletion.yaml: |
        input:
          event_bus:
            topic: payments
            consumer_group: search-payments-resets

        pipeline:
          processors:
          - switch_event_type:
              events:
              - label: CONNECTOR_RESET
                processors:
                - bloblang: |
                    root = {
                      "query": {
                        "bool": {
                          "must": [
                            {
                              "bool": {
                                "should": [
                                  {
                                    "match": {
                                      "kind": "PAYMENT"
                                    }
                                  },
                                  {
                                    "match": {
                                      "kind": "PAYMENT_ACCOUNT"
                                    }
                                  },
                                  {
                                    "match": {
                                      "kind": "PAYMENT_BALANCE"
                                    }
                                  },
                                  {
                                    "match": {
                                      "kind": "PAYMENT_BANK_ACCOUNT"
                                    }
                                  },
                                  {
                                    "match": {
                                      "kind": "PAYMENT_TRANSFER_INITIATION"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "match": {
                                "indexed.connectorId": this.payload.connectorId
                              }
                            },
                            {
                              "match": {
                                "stack": env("STACK")
                              }
                            }
                          ]
                        }
                      }
                    }

              - label: DELETED_TRANSFER_INITIATION
                processors:
                - bloblang: |
                    root = {
                      "query": {
                        "bool": {
                          "must": [
                            {
                              "match": {
                                "kind": "PAYMENT_TRANSFER_INITIATION"
                              }
                            },
                            {
                              "should": [
                                {
                                  "match": {
                                    "indexed.id": this.payload.id
                                  }
                                },
                                {
                                  "match": {
                                    "indexed.provider": this.payload.provider
                                  }
                                }
                              ]
                            },
                            {
                              "match": {
                                "stack": env("STACK")
                              }
                            }
                          ]
                        }
                      }
                    }

        output:
          http_client:
            url: ${OPENSEARCH_URL}/${OPENSEARCH_INDEX}/_delete_by_query
            verb: POST
            headers:
              Content-Type: application/json
            basic_auth:
              enabled: ${BASIC_AUTH_ENABLED}
              username: ${BASIC_AUTH_USERNAME}
              password: ${BASIC_AUTH_PASSWORD}
    payments_ingestion.yaml: |
        input:
          event_bus:
            topic: payments
            consumer_group: search

        pipeline:
          processors:
          - switch_event_type:
              events:
              - label: SAVED_PAYMENT
                processors:
                - bloblang: |
                      root = {
                          "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "reference": this.payload.reference,
                                "provider": this.payload.provider,
                                "createdAt": this.payload.createdAt,
                                "connectorId": this.payload.connectorId,
                                "type": this.payload.type,
                                "status": this.payload.status,
                                "scheme": this.payload.scheme,
                                "asset": this.payload.asset,
                                "initialAmount": this.payload.initialAmount
                            },
                            "kind": "PAYMENT",
                            "when": this.date
                          },
                          "action": "index",
                          "id": "PAYMENT-%s".format(this.payload.id)
                      }
              - label: SAVED_ACCOUNT
                processors:
                - bloblang: |
                      root = {
                        "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "provider": this.payload.provider,
                                "createdAt": this.payload.createdAt,
                                "reference": this.payload.reference,
                                "connectorId": this.payload.connectorId,
                                "defaultAsset": this.payload.defaultAsset,
                                "accountName": this.payload.accountName,
                                "type": this.payload.type
                            },
                            "kind": "PAYMENT_ACCOUNT",
                            "when": this.date
                        },
                        "action": "index",
                        "id": "PAYMENT-ACCOUNT-%s".format(this.payload.id)
                      }
              - label: SAVED_BALANCE
                processors:
                - bloblang: |
                      root = {
                          "document": {
                            "data": this.payload,
                            "indexed": {
                                "accountId": this.payload.accountID,
                                "provider": this.payload.provider,
                                "connectorId": this.payload.connectorId,
                                "createdAt": this.payload.createdAt,
                                "asset": this.payload.asset,
                                "balance": this.payload.balance
                            },
                            "kind": "PAYMENT_BALANCE",
                            "when": this.date
                          },
                          "action": "index",
                          "id": "PAYMENT-BALANCE-%s-%s".format(this.payload.accountId, this.payload.asset)
                        }
              - label: SAVED_BANK_ACCOUNT
                processors:
                - bloblang: |
                      root = {
                        "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "createdAt": this.payload.createdAt,
                                "connectorId": this.payload.connectorId,
                                "provider": this.payload.provider,
                                "name": this.payload.name,
                                "accountNumber": this.payload.accountNumber,
                                "iban": this.payload.iban,
                                "swiftBicCode": this.payload.swiftBicCode,
                                "country": this.payload.country,
                                "provider": this.payload.provider,
                                "accountId": this.payload.accountID
                            },
                            "kind": "PAYMENT_BANK_ACCOUNT",
                            "when": this.date
                        },
                        "action": "index",
                        "id": "PAYMENT-BANK-ACCOUNT-%s".format(this.payload.id)
                      }
              - label: SAVED_TRANSFER_INITIATION
                processors:
                - bloblang: |
                      root = {
                       "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "createdAt": this.payload.createdAt,
                                "scheduledAt": this.payload.scheduledAt,
                                "updatedAt": this.payload.updatedAt,
                                "connectorId": this.payload.connectorId,
                                "description": this.payload.description,
                                "type": this.payload.type,
                                "provider": this.payload.provider,
                                "sourceAccountId": this.payload.sourceAccountID,
                                "destinationAccountId": this.payload.destinationAccountID,
                                "amount": this.payload.amount,
                                "asset": this.payload.asset,
                                "attempts": this.payload.attempts,
                                "status": this.payload.status,
                                "error": this.payload.error,
                                "relatedPayment": this.payload.relatedPayment
                            },
                            "kind": "PAYMENT_TRANSFER_INITIATION",
                            "when": this.date
                       },
                       "action": "index",
                       "id": "PAYMENT-TRANSFER-INITIATION-%s".format(this.payload.id)
                      }

        output:
          resource: elasticsearch
kind: ConfigMap
metadata:
    labels:
        stack: "true"
    name: search-benthos-streams
    namespace: monopod-ledgerv1

apiVersion: v1
data:
    ledger_ingestion_v1.yaml: "input:\n  event_bus:\n    topic: ledger\n    consumer_group: search\n\npipeline:\n  processors:\n  - switch_event_type:\n      events:\n      - label: COMMITTED_TRANSACTIONS\n        version: v1\n        processors:\n        - bloblang: |\n            map account {\n              root = this.map_each(v -> v.value.map_each(v2 -> {\n                \"action\": \"upsert\",\n                \"id\": v.key,\n                \"document\": {\n                  \"data\": {\n                    \"address\": v.key\n                  },\n                  \"indexed\": {\n                    \"address\": v.key\n                  },\n                  \"kind\": \"ACCOUNT\"\n                }\n              }).values()).values().flatten()\n            }\n\n            map tx {\n              root = {\n                \"action\": \"index\",\n                \"id\": \"%s\".format(this.txid),\n                \"document\": {\n                  \"data\": {\n                    \"postings\": this.postings,\n                    \"reference\": this.reference,\n                    \"txid\": this.txid,\n                    \"timestamp\": this.timestamp,\n                    \"metadata\": if this.metadata { this.metadata } else {{}}\n                  },\n                  \"indexed\": {\n                    \"reference\": this.reference,\n                    \"txid\": this.txid,\n                    \"timestamp\": this.timestamp,\n                    \"asset\": this.postings.map_each(p -> p.asset),\n                    \"source\": this.postings.map_each(p -> p.source),\n                    \"destination\": this.postings.map_each(p -> p.destination),\n                    \"amount\": this.postings.map_each(p -> if p.asset.contains(\"/\") {\n                      [\n                        p.amount,\n                        p.amount / if p.asset.split(\"/\").index(1).number(){ range(0, p.asset.split(\"/\").index(1).number()).fold(1, t -> t.tally * 10) } else { 1 } # amount / pow(10, decimal part of asset)\n                      ]\n                    } else { [ p.amount ] }).flatten().map_each(v -> \"%v\".format(v))\n                  },\n                  \"kind\": \"TRANSACTION\"\n                }\n              }\n            }\n\n            map committedTransactions {\n                root = [\n                    this.payload.transactions.map_each(t -> t.apply(\"tx\")).map_each(t -> t.assign({\n                        \"id\": \"TRANSACTION-%s-%s\".format(this.payload.ledger, t.id)\n                    })),\n                    this.payload.transactions.map_each(t -> t.postings.map_each(p -> [{\n                        \"action\": \"upsert\",\n                        \"id\": \"ACCOUNT-%s-%s\".format(this.payload.ledger, p.source),\n                        \"document\": {\n                            \"data\": {\n                                \"address\": p.source,\n                                \"metadata\": {}\n                            },\n                            \"indexed\": {\n                                \"address\": p.source\n                            },\n                            \"kind\": \"ACCOUNT\"\n                        }\n                    }, {\n                        \"action\": \"upsert\",\n                        \"id\": \"ACCOUNT-%s-%s\".format(this.payload.ledger, p.destination),\n                        \"document\": {\n                            \"data\": {\n                                \"address\": p.destination,\n                                \"metadata\": {}\n                            },\n                            \"indexed\": {\n                                \"address\": p.destination\n                            },\n                            \"kind\": \"ACCOUNT\"\n                        }\n                    }])).flatten().flatten()\n                ].flatten().map_each(t -> t.merge({\n                   \"document\": {\n                       \"when\": this.date,\n                       \"ledger\": this.payload.ledger,\n                       \"data\": {\n                           \"ledger\": this.payload.ledger\n                       },\n                       \"indexed\": {\n                           \"ledger\": this.payload.ledger\n                       }\n                   },\n               }))\n            }\n\n            root = this.apply(\"committedTransactions\")\n        - unarchive:\n            format: json_array\n      - label: SAVED_METADATA\n        version: v1\n        processors:\n        - bloblang: |\n            root = this.payload.metadata.map_each(item -> {\n              \"script\": \"if (ctx._source.data.metadata == null) { ctx._source.data.metadata = [params.key: params.value] }  ctx._source.data.metadata[params.key]=params.value\",\n              \"params\": {\n                \"key\": item.key,\n                \"value\": item.value.string()\n              },\n              \"action\": \"update\",\n              \"id\": \"%s-%s-%s\".format(this.payload.targetType, this.payload.ledger, this.payload.targetId),\n              \"upsert\": {\n                \"data\": {\n                  \"address\": this.payload.targetId,\n                  \"metadata\": { item.key: item.value.string() },\n                  \"ledger\": this.payload.ledger\n                },\n                \"indexed\": { \n                  \"address\": this.payload.targetId,\n                  \"ledger\": this.payload.ledger\n                },\n                \"kind\": \"ACCOUNT\",\n                \"when\": this.date\n              }\n            }).values()\n        - unarchive:\n            format: json_array\n\noutput:\n  resource: elasticsearch\n"
    ledger_ingestion_v2.yaml: "input:\n  event_bus:\n    topic: ledger\n    consumer_group: search-ledgerv2\n\npipeline:\n  processors:\n  - log:\n      message: \"receive message: ${! this }\"\n  - switch_event_type:\n      events:\n      - label: COMMITTED_TRANSACTIONS\n        version: v2\n        processors:\n        - bloblang: |\n            map amount {\n              root = [this.amount]\n              let hasDecimals = this.asset.split(\"/\").length() > 1\n              let decimals = if $hasDecimals { this.asset.split(\"/\").index(1).number() } else { 0 }\n              root = if $decimals > 0 {\n                root.append(\n                  this.amount / range(0, $decimals).fold(1, t -> t.tally * 10) # Just a pow...\n                )\n              }\n              root = root.flatten()\n            }\n                \n            map tx {\n              root = {\n                \"action\": \"index\",\n                \"id\": \"TRANSACTION-%s-%s\".format(this.ledger, this.transaction.id),\n                \"document\": {\n                  \"data\": {\n                    \"postings\": this.transaction.postings,\n                    \"reference\": this.transaction.reference,\n                    \"txid\": this.transaction.id,\n                    \"timestamp\": this.transaction.timestamp,\n                    \"metadata\": if this.transaction.metadata { this.transaction.metadata } else {{}}\n                  },\n                  \"indexed\": {\n                    \"reference\": this.transaction.reference,\n                    \"txid\": this.transaction.id,\n                    \"timestamp\": this.transaction.timestamp,\n                    \"asset\": this.transaction.postings.map_each(p -> p.asset),\n                    \"source\": this.transaction.postings.map_each(p -> p.source),\n                    \"destination\": this.transaction.postings.map_each(p -> p.destination),\n                    \"amount\": this.transaction.postings.map_each(p -> p.apply(\"amount\"))\n                  },\n                  \"kind\": \"TRANSACTION\",\n                  \"when\": this.date\n                }\n              }\n            }\n                      \n            map account {\n              root = {\n                \"action\": \"upsert\",\n                \"id\": \"ACCOUNT-%s-%s\".format(this.ledger, this.account),\n                \"document\": {\n                  \"data\": { \n                    \"address\": this.account,\n                    \"metadata\": {}\n                  },\n                  \"indexed\": { \n                    \"address\": this.account\n                  },\n                  \"kind\": \"ACCOUNT\",\n                  \"when\": this.date\n                }\n              }\n            }\n                  \n            root = []\n            root = root.append(\n              this.payload.transactions.map_each(transaction -> {\n                \"transaction\": transaction,\n                \"ledger\": this.payload.ledger\n              }.apply(\"tx\"))\n            )\n            root = root.append(\n              this.payload.transactions.\n                map_each(transaction -> transaction.postings.map_each(posting -> [\n                  posting.source,\n                  posting.destination\n                ]).\n                flatten().\n                map_each(account -> {\n                  \"account\": account,\n                  \"ledger\": this.payload.ledger\n                }.apply(\"account\"))\n              ).\n              flatten()\n            )\n            root = root.append(\n              this.payload.accountMetadata.map_each(item -> item.value.map_each(metadata -> {\n                \"script\": \"ctx._source.data.metadata[params.key]=params.value\",\n                \"params\": {\n                  \"key\": metadata.key,\n                  \"value\": metadata.value\n                },\n                \"action\": \"update\",\n                \"id\": \"ACCOUNT-%s-%s\".format(this.payload.ledger, item.key),\n                \"upsert\": {\n                  \"data\": { \n                    \"address\": item.key,\n                    \"metadata\": { metadata.key: metadata.value }\n                  },\n                  \"indexed\": { \n                    \"address\": item.key\n                  },\n                  \"kind\": \"ACCOUNT\",\n                  \"when\": this.date\n                }\n              }).values()).values().flatten()\n            )\n            root = root.flatten()\n              \n            let overlay = {\n              \"data\": {\n                \"ledger\": this.payload.ledger\n              },\n              \"indexed\": {\n                \"ledger\": this.payload.ledger  \n              }\n            }\n              \n            root = root.map_each(cmd -> match cmd.action {\n              cmd.action == \"update\" => if cmd.exists(\"upsert\") { cmd.merge({\n                \"upsert\": $overlay\n              }) } else { cmd },\n              _ => cmd.merge({\n                \"document\": $overlay\n              }) \n            })\n        - log:\n            message: \"Computed: ${! this }\"\n        - unarchive:\n            format: json_array\n      - label: SAVED_METADATA\n        version: v2\n        processors:\n        - bloblang: |\n            root = this.payload.metadata.map_each(item -> {\n              \"script\": \"if (ctx._source.data.metadata == null) { ctx._source.data.metadata = [params.key: params.value] }  ctx._source.data.metadata[params.key]=params.value\",\n              \"params\": {\n                \"key\": item.key,\n                \"value\": item.value\n              },\n              \"action\": \"update\",\n              \"id\": \"%s-%s-%s\".format(this.payload.targetType, this.payload.ledger, this.payload.targetId),\n              \"upsert\": {\n                \"data\": { \n                  \"address\": this.payload.targetId,\n                  \"metadata\": { item.key: item.value },\n                  \"ledger\": this.payload.ledger\n                },\n                \"indexed\": { \n                  \"address\": this.payload.targetId,\n                  \"ledger\": this.payload.ledger\n                },\n                \"kind\": \"ACCOUNT\",\n                \"when\": this.date\n              }\n            }).values()\n        - unarchive:\n            format: json_array\n      - label: DELETED_METADATA\n        version: v2\n        processors:\n        - bloblang: |\n            root = {\n              \"script\": \"ctx._source.data.metadata.remove(params.key)\",\n              \"params\": {\n                \"key\": this.payload.key\n              },\n              \"action\": \"update\",\n              \"id\": \"%s-%s-%s\".format(this.payload.targetType, this.payload.ledger, this.payload.targetId)\n            }\n\noutput:\n  resource: elasticsearch\n"
    ledger_reindex_accounts_v1.yaml: "input:\n  http_server:\n    path: /\n\npipeline:\n  processors:\n  - bloblang: |\n      meta ledger = this.ledger\n      meta batchSize = 100\n  - postgres_query:\n      service: ledger\n      query: 'select count(*) as accounts_count from \"${! meta(\"ledger\") }\".accounts'\n  - unarchive:\n      format: json_array\n  - bloblang: |\n      meta loopCount = (this.accounts_count.number() / meta(\"batchSize\").number()).ceil()\n      meta loopIndex = 0\n  - bloblang: |\n      root = if meta(\"loopCount\") == \"0\" {\n        deleted() \n      }\n  - while:\n      check: 'meta(\"loopIndex\") < meta(\"loopCount\")'\n      processors:\n      - postgres_query:\n          service: ledger\n          query: |\n            select address, metadata\n            from \"${! meta(\"ledger\") }\".accounts\n            offset ${! meta(\"loopIndex\").number() * meta(\"batchSize\").number() }\n            limit ${! meta(\"batchSize\") }\n      - bloblang:\n          meta loopIndex = meta(\"loopIndex\").number() + 1\n      - unarchive:\n          format: json_array\n      - bloblang: |\n          root = this.assign({\n            \"metadata\": this.metadata.parse_json()\n          })\n      - bloblang: |\n          root = {\n            \"document\": {\n              \"data\": {\n                \"address\": this.address,\n                \"ledger\": meta(\"ledger\"),\n                \"metadata\": this.metadata\n              },\n              \"indexed\": {\n                \"address\": this.address,\n                \"ledger\": meta(\"ledger\")\n              },\n              \"kind\": \"ACCOUNT\",\n              \"ledger\": meta(\"ledger\")\n            },\n            \"id\": \"ACCOUNT-%s-%s\".format(meta(\"ledger\"), this.address),\n            \"action\": \"upsert\"\n          }\n\noutput:\n  resource: elasticsearch\n"
    ledger_reindex_accounts_v2.yaml: "input:\n  http_server:\n    path: /\n\npipeline:\n  processors:\n  - bloblang: |\n      meta ledger = this.ledger\n  - postgres_query:\n      service: ledger\n      query: |\n        select address, metadata\n        from \"${! meta(\"ledger\") }\".accounts\n  - unarchive:\n      format: json_array\n  - bloblang: |\n      root = this.assign({\n        \"metadata\": this.metadata.parse_json()\n      })\n  - bloblang: |\n      root = {\n        \"document\": {\n          \"data\": { \n            \"address\": this.address,\n            \"ledger\": meta(\"ledger\"),\n            \"metadata\": this.metadata\n          },\n          \"indexed\": {\n            \"address\": this.address,\n            \"ledger\": meta(\"ledger\")\n          },\n          \"kind\": \"ACCOUNT\",\n          \"ledger\": meta(\"ledger\"),\n          \"when\": this.date\n        },\n        \"id\": \"ACCOUNT-%s-%s\".format(meta(\"ledger\"), this.address),\n        \"action\": \"upsert\"\n      }\n\noutput:\n  resource: elasticsearch\n"
    ledger_reindex_all_v1.yaml: |
        input:
          http_server:
            path: /

        pipeline:
          processors:
          - postgres_query:
              service: ledger
              query: 'select * from "_system".ledgers'
          - unarchive:
              format: json_array

        output:
          broker:
            outputs:
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_v1
    ledger_reindex_all_v2.yaml: |
        input:
          http_server:
            path: /

        pipeline:
          processors:
          - postgres_query:
              service: ledger
              query: 'select * from "_system".ledgers'
          - unarchive:
              format: json_array
          - log:
              message: "Process ledger: ${! this.ledger }"

        output:
          broker:
            outputs:
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_v2
    ledger_reindex_transactions_v1.yaml: "input:\n  http_server:\n    path: /\n\npipeline:\n  processors:\n  - bloblang: |\n      meta ledger = this.ledger\n      meta batchSize = 100\n  - postgres_query:\n      service: ledger\n      query: 'select count(*) as transactions_count from \"${! meta(\"ledger\") }\".transactions'\n  - unarchive:\n      format: json_array\n  - bloblang: |\n      meta loopCount = (this.transactions_count.number() / meta(\"batchSize\").number()).ceil()\n      meta loopIndex = 0\n  - bloblang: |\n        root = if meta(\"loopCount\") == \"0\" {\n          deleted() \n        }\n  - while:\n      check: 'meta(\"loopIndex\") < meta(\"loopCount\")'\n      processors:\n      - postgres_query:\n          service: ledger\n          query: |\n            select id, timestamp, reference, metadata, postings\n            from \"${! meta(\"ledger\") }\".transactions\n            offset ${! meta(\"loopIndex\").number() * meta(\"batchSize\").number() }\n            limit ${! meta(\"batchSize\") }\n      - bloblang:\n          meta loopIndex = meta(\"loopIndex\").number() + 1\n      - unarchive:\n          format: json_array\n      - bloblang: |\n          root = this.assign({\n            \"postings\": this.postings.parse_json(),\n            \"metadata\": this.metadata.parse_json()\n          })\n      - bloblang: |\n          root = {\n            \"id\": \"TRANSACTION-%s-%s\".format(meta(\"ledger\"), this.id),\n            \"action\": \"upsert\",\n            \"document\": {\n              \"data\": {\n                \"postings\": this.postings,\n                \"reference\": this.reference,\n                \"txid\": this.txid,\n                \"timestamp\": this.timestamp,\n                \"metadata\": if this.metadata { this.metadata } else {{}},\n                \"ledger\": meta(\"ledger\")\n              },\n              \"indexed\": {\n                \"reference\": this.reference,\n                \"txid\": this.id,\n                \"timestamp\": this.timestamp,\n                \"asset\": this.postings.map_each(p -> p.asset),\n                \"source\": this.postings.map_each(p -> p.source),\n                \"destination\": this.postings.map_each(p -> p.destination),\n                \"amount\": this.postings.map_each(p -> if p.asset.contains(\"/\") {\n                  [\n                    p.amount,\n                    p.amount / range(0, p.asset.split(\"/\").index(1).number()).fold(1, t -> t.tally * 10) # amount / pow(10, decimal part of asset)\n                  ]\n                } else { [ p.amount ] }).flatten().map_each(v -> \"%v\".format(v)),\n                \"ledger\": meta(\"ledger\")\n              },\n              \"kind\": \"TRANSACTION\",\n              \"ledger\": meta(\"ledger\"),\n              \"when\": this.date\n            }\n          }\n\noutput:\n  resource: elasticsearch\n"
    ledger_reindex_transactions_v2.yaml: |
        input:
          http_server:
            path: /

        pipeline:
          processors:
          - bloblang: |
              meta ledger = this.ledger
          - postgres_query:
              service: ledger
              query: |
                select id::varchar as id, timestamp, reference, metadata, postings
                from "${! meta("ledger") }".transactions;
          - unarchive:
              format: json_array
          - bloblang: |
              root = this.assign({
                "postings": this.postings.parse_json(),
                "metadata": this.metadata.parse_json()
              })
          - bloblang: |
                root = {
                  "id": "TRANSACTION-%s-%s".format(meta("ledger"), this.id),
                  "action": "upsert",
                  "document": {
                    "data": {
                      "postings": this.postings,
                      "reference": this.reference,
                      "txid": this.id,
                      "timestamp": this.timestamp,
                      "metadata": if this.metadata { this.metadata } else {{}},
                      "ledger": meta("ledger")
                    },
                    "indexed": {
                      "reference": this.reference,
                      "txid": this.id,
                      "timestamp": this.timestamp,
                      "asset": this.postings.map_each(p -> p.asset),
                      "source": this.postings.map_each(p -> p.source),
                      "destination": this.postings.map_each(p -> p.destination),
                      "amount": this.postings.map_each(p -> if p.asset.contains("/") {
                        [
                          p.amount,
                          p.amount / range(0, p.asset.split("/").index(1).number()).fold(1, t -> t.tally * 10) # amount / pow(10, decimal part of asset)
                        ]
                      } else { [ p.amount ] }).flatten().map_each(v -> "%v".format(v)),
                      "ledger": meta("ledger")
                    },
                    "kind": "TRANSACTION",
                    "ledger": meta("ledger"),
                    "when": this.date
                  }
                }

        output:
          resource: elasticsearch
    ledger_reindex_v1.yaml: |
        input:
          http_server:
            path: /

        output:
          broker:
            outputs:
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_volumes_v1
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_transactions_v1
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_accounts_v1
    ledger_reindex_v2.yaml: |
        input:
          http_server:
            path: /

        output:
          broker:
            outputs:
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_transactions_v2
            - http_client:
                verb: POST
                url: http://localhost:4195/ledger_reindex_accounts_v2
    ledger_reindex_volumes_v1.yaml: "input:\n  http_server:\n    path: /\n\npipeline:\n  processors:\n  - bloblang: |\n      meta ledger = this.ledger\n      meta batchSize = 100\n  - postgres_query:\n      service: ledger\n      query: 'select count(*) as volumes_count from \"${! meta(\"ledger\") }\".volumes'\n  - unarchive:\n      format: json_array\n  - bloblang: |\n      meta loopCount = (this.volumes_count.number() / meta(\"batchSize\").number()).ceil()\n      meta loopIndex = 0\n  - bloblang: |\n      root = if meta(\"loopCount\") == \"0\" {\n        deleted() \n      }\n  - while:\n      check: 'meta(\"loopIndex\") < meta(\"loopCount\")'\n      processors:\n      - postgres_query:\n          service: ledger\n          query: |\n            select account, asset, input, output\n            from \"${! meta(\"ledger\") }\".volumes\n            offset ${! meta(\"loopIndex\").number() * meta(\"batchSize\").number() }\n            limit ${! meta(\"batchSize\") }\n      - bloblang:\n          meta loopIndex = meta(\"loopIndex\").number() + 1\n      - unarchive:\n          format: json_array\n      - bloblang: |\n          root = {\n            \"id\": \"ASSET-%s-%s-%s\".format(meta(\"ledger\"), this.account, this.asset),\n            \"action\": \"upsert\",\n            \"document\": {\n              \"data\": {\n                \"name\": this.asset,\n                \"input\": this.input,\n                \"output\": this.output,\n                \"account\": this.account,\n                \"ledger\": meta(\"ledger\")\n              },\n              \"indexed\": {\n                \"account\": this.account,\n                \"name\": this.asset,\n                \"ledger\": meta(\"ledger\")\n              },\n              \"kind\": \"ASSET\",\n              \"ledger\": meta(\"ledger\"),\n              \"when\": this.date\n            }\n          }\n\noutput:\n  resource: elasticsearch\n"
    payments_deletion.yaml: "input:\n  event_bus:\n    topic: payments\n    consumer_group: search-payments-resets\n\npipeline:\n  processors:\n  - switch_event_type:\n      events:\n      - label: CONNECTOR_RESET\n        version: v1\n        processors:\n        - bloblang: |\n            root = {\n              \"query\": {\n                \"bool\": {\n                  \"must\": [\n                    {\n                      \"bool\": {\n                        \"should\": [\n                          {\n                            \"match\": {\n                              \"kind\": \"PAYMENT\"\n                            }\n                          },\n                          {\n                            \"match\": {\n                              \"kind\": \"PAYMENT_POOL\"\n                            }\n                          },\n                          {\n                            \"match\": {\n                              \"kind\": \"PAYMENT_ACCOUNT\"\n                            }\n                          },\n                          {\n                            \"match\": {\n                              \"kind\": \"PAYMENT_BALANCE\"\n                            }\n                          },\n                          {\n                            \"match\": {\n                              \"kind\": \"PAYMENT_BANK_ACCOUNT\"\n                            }\n                          },\n                          {\n                            \"match\": {\n                              \"kind\": \"PAYMENT_TRANSFER_INITIATION\"\n                            }\n                          }\n                        ]\n                      }\n                    },\n                    {\n                      \"match\": {\n                        \"indexed.connectorId\": this.payload.connectorId\n                      }\n                    },\n                    {\n                      \"match\": {\n                        \"stack\": env(\"STACK\")\n                      }\n                    }\n                  ]\n                }\n              }\n            }\n\n      - label: DELETED_POOL\n        version: v1\n        processors:\n        - bloblang: |\n            root = {\n              \"query\": {\n                \"bool\": {\n                  \"must\": [\n                    {\n                      \"match\": {\n                        \"kind\": \"PAYMENT_POOL\"\n                      }\n                    },\n                    {\n                      \"match\": {\n                        \"indexed.id\": this.payload.id\n                      } \n                    },\n                    {\n                      \"match\": {\n                        \"stack\": env(\"STACK\")\n                      }\n                    }\n                  ]\n                }\n              }\n            }\n\n      - label: DELETED_TRANSFER_INITIATION\n        version: v1\n        processors:\n        - bloblang: |\n            root = {\n              \"query\": {\n                \"bool\": {\n                  \"must\": [\n                    {\n                      \"match\": {\n                        \"kind\": \"PAYMENT_TRANSFER_INITIATION\"\n                      }\n                    },\n                    {\n                      \"should\": [\n                        {\n                          \"match\": {\n                            \"indexed.id\": this.payload.id\n                          }\n                        },\n                        {\n                          \"match\": {\n                            \"indexed.provider\": this.payload.provider\n                          }\n                        }\n                      ]\n                    },\n                    {\n                      \"match\": {\n                        \"stack\": env(\"STACK\")\n                      }\n                    }\n                  ]\n                }\n              }\n            }\n\noutput:\n  http_client:\n    url: ${OPENSEARCH_URL}/${OPENSEARCH_INDEX}/_delete_by_query\n    verb: POST\n    headers:\n      Content-Type: application/json\n    basic_auth:\n      enabled: ${BASIC_AUTH_ENABLED}\n      username: ${BASIC_AUTH_USERNAME}\n      password: ${BASIC_AUTH_PASSWORD}\n"
    payments_ingestion.yaml: |
        input:
          event_bus:
            topic: payments
            consumer_group: search

        pipeline:
          processors:
          - switch_event_type:
              events:
              - label: SAVED_PAYMENT
                version: v1
                processors:
                - bloblang: |
                      root = {
                          "document": {
                            "data": this.payload.without("rawData"),
                            "indexed": {
                                "id": this.payload.id,
                                "reference": this.payload.reference,
                                "provider": this.payload.provider,
                                "createdAt": this.payload.createdAt,
                                "connectorId": this.payload.connectorId,
                                "type": this.payload.type,
                                "status": this.payload.status,
                                "scheme": this.payload.scheme,
                                "asset": this.payload.asset,
                                "initialAmount": this.payload.initialAmount,
                                "amount": this.payload.amount
                            },
                            "kind": "PAYMENT",
                            "when": this.date
                          },
                          "action": "index",
                          "id": "PAYMENT-%s".format(this.payload.id)
                      }
              - label: SAVED_ACCOUNT
                version: v1
                processors:
                - bloblang: |
                      root = {
                        "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "provider": this.payload.provider,
                                "createdAt": this.payload.createdAt,
                                "reference": this.payload.reference,
                                "connectorId": this.payload.connectorId,
                                "defaultAsset": this.payload.defaultAsset,
                                "accountName": this.payload.accountName,
                                "type": this.payload.type
                            },
                            "kind": "PAYMENT_ACCOUNT",
                            "when": this.date
                        },
                        "action": "index",
                        "id": "PAYMENT-ACCOUNT-%s".format(this.payload.id)
                      }
              - label: SAVED_BALANCE
                version: v1
                processors:
                - bloblang: |
                      root = {
                          "document": {
                            "data": this.payload,
                            "indexed": {
                                "accountId": this.payload.accountID,
                                "provider": this.payload.provider,
                                "connectorId": this.payload.connectorId,
                                "createdAt": this.payload.createdAt,
                                "asset": this.payload.asset,
                                "balance": this.payload.balance
                            },
                            "kind": "PAYMENT_BALANCE",
                            "when": this.date
                          },
                          "action": "index",
                          "id": "PAYMENT-BALANCE-%s-%s".format(this.payload.accountID, this.payload.asset)
                        }
              - label: SAVED_BANK_ACCOUNT
                version: v1
                processors:
                - bloblang: |
                      root = {
                        "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "createdAt": this.payload.createdAt,
                                "provider": this.payload.provider,
                                "name": this.payload.name,
                                "accountNumber": this.payload.accountNumber,
                                "iban": this.payload.iban,
                                "swiftBicCode": this.payload.swiftBicCode,
                                "country": this.payload.country
                            },
                            "kind": "PAYMENT_BANK_ACCOUNT",
                            "when": this.date
                        },
                        "action": "index",
                        "id": "PAYMENT-BANK-ACCOUNT-%s".format(this.payload.id)
                      }
              - label: SAVED_POOL
                version: v1
                processors:
                - bloblang: |
                      root = {
                        "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "createdAt": this.payload.createdAt,
                                "name": this.payload.name,
                                "accountIDs": this.payload.accountIDs,
                            },
                            "kind": "PAYMENT_POOL",
                            "when": this.date
                        },
                        "action": "index",
                        "id": "PAYMENT-POOL-%s".format(this.payload.id)
                      }
              - label: SAVED_TRANSFER_INITIATION
                version: v1
                processors:
                - bloblang: |
                      root = {
                       "document": {
                            "data": this.payload,
                            "indexed": {
                                "id": this.payload.id,
                                "createdAt": this.payload.createdAt,
                                "scheduledAt": this.payload.scheduledAt,
                                "updatedAt": this.payload.updatedAt,
                                "connectorId": this.payload.connectorId,
                                "description": this.payload.description,
                                "type": this.payload.type,
                                "provider": this.payload.provider,
                                "sourceAccountId": this.payload.sourceAccountID,
                                "destinationAccountId": this.payload.destinationAccountID,
                                "amount": this.payload.amount,
                                "asset": this.payload.asset,
                                "attempts": this.payload.attempts,
                                "status": this.payload.status,
                                "error": this.payload.error,
                                "relatedPayment": this.payload.relatedPayment
                            },
                            "kind": "PAYMENT_TRANSFER_INITIATION",
                            "when": this.date
                       },
                       "action": "index",
                       "id": "PAYMENT-TRANSFER-INITIATION-%s".format(this.payload.id)
                      }

        output:
          resource: elasticsearch
kind: ConfigMap
metadata:
    labels:
        stack: "true"
    name: search-benthos-streams
    namespace: multipod-ledger-v2-0-0-beta-7

<?php
/**
 * PaymentsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Formance
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Formance Stack API
 *
 * Open, modular foundation for unique payments flows  # Introduction This API is documented in **OpenAPI format**.  # Authentication Formance Stack offers one forms of authentication:   - OAuth2 OAuth2 - an open protocol to allow secure authorization in a simple and standard method from web, mobile and desktop applications. <SecurityDefinitions />
 *
 * The version of the OpenAPI document: v1.0.20230301
 * Contact: support@formance.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Formance\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Formance\ApiException;
use Formance\Configuration;
use Formance\HeaderSelector;
use Formance\ObjectSerializer;

/**
 * PaymentsApi Class Doc Comment
 *
 * @category Class
 * @package  Formance
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PaymentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'connectorsStripeTransfer' => [
            'application/json',
        ],
        'connectorsTransfer' => [
            'application/json',
        ],
        'getConnectorTask' => [
            'application/json',
        ],
        'getPayment' => [
            'application/json',
        ],
        'installConnector' => [
            'application/json',
        ],
        'listAllConnectors' => [
            'application/json',
        ],
        'listConfigsAvailableConnectors' => [
            'application/json',
        ],
        'listConnectorTasks' => [
            'application/json',
        ],
        'listConnectorsTransfers' => [
            'application/json',
        ],
        'listPayments' => [
            'application/json',
        ],
        'paymentslistAccounts' => [
            'application/json',
        ],
        'readConnectorConfig' => [
            'application/json',
        ],
        'resetConnector' => [
            'application/json',
        ],
        'uninstallConnector' => [
            'application/json',
        ],
        'updateMetadata' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation connectorsStripeTransfer
     *
     * Transfer funds between Stripe accounts
     *
     * @param  \Formance\Model\StripeTransferRequest $stripe_transfer_request stripe_transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsStripeTransfer'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function connectorsStripeTransfer($stripe_transfer_request, string $contentType = self::contentTypes['connectorsStripeTransfer'][0])
    {
        list($response) = $this->connectorsStripeTransferWithHttpInfo($stripe_transfer_request, $contentType);
        return $response;
    }

    /**
     * Operation connectorsStripeTransferWithHttpInfo
     *
     * Transfer funds between Stripe accounts
     *
     * @param  \Formance\Model\StripeTransferRequest $stripe_transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsStripeTransfer'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectorsStripeTransferWithHttpInfo($stripe_transfer_request, string $contentType = self::contentTypes['connectorsStripeTransfer'][0])
    {
        $request = $this->connectorsStripeTransferRequest($stripe_transfer_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectorsStripeTransferAsync
     *
     * Transfer funds between Stripe accounts
     *
     * @param  \Formance\Model\StripeTransferRequest $stripe_transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsStripeTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectorsStripeTransferAsync($stripe_transfer_request, string $contentType = self::contentTypes['connectorsStripeTransfer'][0])
    {
        return $this->connectorsStripeTransferAsyncWithHttpInfo($stripe_transfer_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectorsStripeTransferAsyncWithHttpInfo
     *
     * Transfer funds between Stripe accounts
     *
     * @param  \Formance\Model\StripeTransferRequest $stripe_transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsStripeTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectorsStripeTransferAsyncWithHttpInfo($stripe_transfer_request, string $contentType = self::contentTypes['connectorsStripeTransfer'][0])
    {
        $returnType = 'object';
        $request = $this->connectorsStripeTransferRequest($stripe_transfer_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectorsStripeTransfer'
     *
     * @param  \Formance\Model\StripeTransferRequest $stripe_transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsStripeTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function connectorsStripeTransferRequest($stripe_transfer_request, string $contentType = self::contentTypes['connectorsStripeTransfer'][0])
    {

        // verify the required parameter 'stripe_transfer_request' is set
        if ($stripe_transfer_request === null || (is_array($stripe_transfer_request) && count($stripe_transfer_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stripe_transfer_request when calling connectorsStripeTransfer'
            );
        }


        $resourcePath = '/api/payments/connectors/stripe/transfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($stripe_transfer_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($stripe_transfer_request));
            } else {
                $httpBody = $stripe_transfer_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation connectorsTransfer
     *
     * Transfer funds between Connector accounts
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\TransferRequest $transfer_request transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsTransfer'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\TransferResponse
     */
    public function connectorsTransfer($connector, $transfer_request, string $contentType = self::contentTypes['connectorsTransfer'][0])
    {
        list($response) = $this->connectorsTransferWithHttpInfo($connector, $transfer_request, $contentType);
        return $response;
    }

    /**
     * Operation connectorsTransferWithHttpInfo
     *
     * Transfer funds between Connector accounts
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\TransferRequest $transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsTransfer'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\TransferResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectorsTransferWithHttpInfo($connector, $transfer_request, string $contentType = self::contentTypes['connectorsTransfer'][0])
    {
        $request = $this->connectorsTransferRequest($connector, $transfer_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\TransferResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\TransferResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\TransferResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\TransferResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\TransferResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectorsTransferAsync
     *
     * Transfer funds between Connector accounts
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\TransferRequest $transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectorsTransferAsync($connector, $transfer_request, string $contentType = self::contentTypes['connectorsTransfer'][0])
    {
        return $this->connectorsTransferAsyncWithHttpInfo($connector, $transfer_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectorsTransferAsyncWithHttpInfo
     *
     * Transfer funds between Connector accounts
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\TransferRequest $transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectorsTransferAsyncWithHttpInfo($connector, $transfer_request, string $contentType = self::contentTypes['connectorsTransfer'][0])
    {
        $returnType = '\Formance\Model\TransferResponse';
        $request = $this->connectorsTransferRequest($connector, $transfer_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectorsTransfer'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\TransferRequest $transfer_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['connectorsTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function connectorsTransferRequest($connector, $transfer_request, string $contentType = self::contentTypes['connectorsTransfer'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling connectorsTransfer'
            );
        }

        // verify the required parameter 'transfer_request' is set
        if ($transfer_request === null || (is_array($transfer_request) && count($transfer_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transfer_request when calling connectorsTransfer'
            );
        }


        $resourcePath = '/api/payments/connectors/{connector}/transfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($transfer_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($transfer_request));
            } else {
                $httpBody = $transfer_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorTask
     *
     * Read a specific task of the connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $task_id The task ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorTask'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\TaskResponse
     */
    public function getConnectorTask($connector, $task_id, string $contentType = self::contentTypes['getConnectorTask'][0])
    {
        list($response) = $this->getConnectorTaskWithHttpInfo($connector, $task_id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorTaskWithHttpInfo
     *
     * Read a specific task of the connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $task_id The task ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorTask'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\TaskResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorTaskWithHttpInfo($connector, $task_id, string $contentType = self::contentTypes['getConnectorTask'][0])
    {
        $request = $this->getConnectorTaskRequest($connector, $task_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\TaskResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\TaskResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\TaskResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\TaskResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorTaskAsync
     *
     * Read a specific task of the connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $task_id The task ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorTaskAsync($connector, $task_id, string $contentType = self::contentTypes['getConnectorTask'][0])
    {
        return $this->getConnectorTaskAsyncWithHttpInfo($connector, $task_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorTaskAsyncWithHttpInfo
     *
     * Read a specific task of the connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $task_id The task ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorTaskAsyncWithHttpInfo($connector, $task_id, string $contentType = self::contentTypes['getConnectorTask'][0])
    {
        $returnType = '\Formance\Model\TaskResponse';
        $request = $this->getConnectorTaskRequest($connector, $task_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorTask'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $task_id The task ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorTaskRequest($connector, $task_id, string $contentType = self::contentTypes['getConnectorTask'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling getConnectorTask'
            );
        }

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getConnectorTask'
            );
        }


        $resourcePath = '/api/payments/connectors/{connector}/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }
        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPayment
     *
     * Get a payment
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayment'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\PaymentResponse
     */
    public function getPayment($payment_id, string $contentType = self::contentTypes['getPayment'][0])
    {
        list($response) = $this->getPaymentWithHttpInfo($payment_id, $contentType);
        return $response;
    }

    /**
     * Operation getPaymentWithHttpInfo
     *
     * Get a payment
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayment'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\PaymentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentWithHttpInfo($payment_id, string $contentType = self::contentTypes['getPayment'][0])
    {
        $request = $this->getPaymentRequest($payment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\PaymentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\PaymentResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\PaymentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\PaymentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\PaymentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentAsync
     *
     * Get a payment
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentAsync($payment_id, string $contentType = self::contentTypes['getPayment'][0])
    {
        return $this->getPaymentAsyncWithHttpInfo($payment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentAsyncWithHttpInfo
     *
     * Get a payment
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentAsyncWithHttpInfo($payment_id, string $contentType = self::contentTypes['getPayment'][0])
    {
        $returnType = '\Formance\Model\PaymentResponse';
        $request = $this->getPaymentRequest($payment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayment'
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaymentRequest($payment_id, string $contentType = self::contentTypes['getPayment'][0])
    {

        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling getPayment'
            );
        }


        $resourcePath = '/api/payments/payments/{paymentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation installConnector
     *
     * Install a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\ConnectorConfig $connector_config connector_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installConnector'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function installConnector($connector, $connector_config, string $contentType = self::contentTypes['installConnector'][0])
    {
        $this->installConnectorWithHttpInfo($connector, $connector_config, $contentType);
    }

    /**
     * Operation installConnectorWithHttpInfo
     *
     * Install a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\ConnectorConfig $connector_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installConnector'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function installConnectorWithHttpInfo($connector, $connector_config, string $contentType = self::contentTypes['installConnector'][0])
    {
        $request = $this->installConnectorRequest($connector, $connector_config, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation installConnectorAsync
     *
     * Install a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\ConnectorConfig $connector_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function installConnectorAsync($connector, $connector_config, string $contentType = self::contentTypes['installConnector'][0])
    {
        return $this->installConnectorAsyncWithHttpInfo($connector, $connector_config, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation installConnectorAsyncWithHttpInfo
     *
     * Install a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\ConnectorConfig $connector_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function installConnectorAsyncWithHttpInfo($connector, $connector_config, string $contentType = self::contentTypes['installConnector'][0])
    {
        $returnType = '';
        $request = $this->installConnectorRequest($connector, $connector_config, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'installConnector'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  \Formance\Model\ConnectorConfig $connector_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function installConnectorRequest($connector, $connector_config, string $contentType = self::contentTypes['installConnector'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling installConnector'
            );
        }

        // verify the required parameter 'connector_config' is set
        if ($connector_config === null || (is_array($connector_config) && count($connector_config) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector_config when calling installConnector'
            );
        }


        $resourcePath = '/api/payments/connectors/{connector}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($connector_config)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($connector_config));
            } else {
                $httpBody = $connector_config;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAllConnectors
     *
     * List all installed connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllConnectors'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\ConnectorsResponse
     */
    public function listAllConnectors(string $contentType = self::contentTypes['listAllConnectors'][0])
    {
        list($response) = $this->listAllConnectorsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listAllConnectorsWithHttpInfo
     *
     * List all installed connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllConnectors'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\ConnectorsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAllConnectorsWithHttpInfo(string $contentType = self::contentTypes['listAllConnectors'][0])
    {
        $request = $this->listAllConnectorsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\ConnectorsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\ConnectorsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\ConnectorsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\ConnectorsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\ConnectorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAllConnectorsAsync
     *
     * List all installed connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAllConnectorsAsync(string $contentType = self::contentTypes['listAllConnectors'][0])
    {
        return $this->listAllConnectorsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAllConnectorsAsyncWithHttpInfo
     *
     * List all installed connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAllConnectorsAsyncWithHttpInfo(string $contentType = self::contentTypes['listAllConnectors'][0])
    {
        $returnType = '\Formance\Model\ConnectorsResponse';
        $request = $this->listAllConnectorsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAllConnectors'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAllConnectorsRequest(string $contentType = self::contentTypes['listAllConnectors'][0])
    {


        $resourcePath = '/api/payments/connectors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConfigsAvailableConnectors
     *
     * List the configs of each available connector
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConfigsAvailableConnectors'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\ConnectorsConfigsResponse
     */
    public function listConfigsAvailableConnectors(string $contentType = self::contentTypes['listConfigsAvailableConnectors'][0])
    {
        list($response) = $this->listConfigsAvailableConnectorsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listConfigsAvailableConnectorsWithHttpInfo
     *
     * List the configs of each available connector
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConfigsAvailableConnectors'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\ConnectorsConfigsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConfigsAvailableConnectorsWithHttpInfo(string $contentType = self::contentTypes['listConfigsAvailableConnectors'][0])
    {
        $request = $this->listConfigsAvailableConnectorsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\ConnectorsConfigsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\ConnectorsConfigsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\ConnectorsConfigsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\ConnectorsConfigsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\ConnectorsConfigsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConfigsAvailableConnectorsAsync
     *
     * List the configs of each available connector
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConfigsAvailableConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConfigsAvailableConnectorsAsync(string $contentType = self::contentTypes['listConfigsAvailableConnectors'][0])
    {
        return $this->listConfigsAvailableConnectorsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConfigsAvailableConnectorsAsyncWithHttpInfo
     *
     * List the configs of each available connector
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConfigsAvailableConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConfigsAvailableConnectorsAsyncWithHttpInfo(string $contentType = self::contentTypes['listConfigsAvailableConnectors'][0])
    {
        $returnType = '\Formance\Model\ConnectorsConfigsResponse';
        $request = $this->listConfigsAvailableConnectorsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConfigsAvailableConnectors'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConfigsAvailableConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConfigsAvailableConnectorsRequest(string $contentType = self::contentTypes['listConfigsAvailableConnectors'][0])
    {


        $resourcePath = '/api/payments/connectors/configs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConnectorTasks
     *
     * List tasks from a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorTasks'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\TasksCursor
     */
    public function listConnectorTasks($connector, $page_size = 15, $cursor = null, string $contentType = self::contentTypes['listConnectorTasks'][0])
    {
        list($response) = $this->listConnectorTasksWithHttpInfo($connector, $page_size, $cursor, $contentType);
        return $response;
    }

    /**
     * Operation listConnectorTasksWithHttpInfo
     *
     * List tasks from a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorTasks'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\TasksCursor, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConnectorTasksWithHttpInfo($connector, $page_size = 15, $cursor = null, string $contentType = self::contentTypes['listConnectorTasks'][0])
    {
        $request = $this->listConnectorTasksRequest($connector, $page_size, $cursor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\TasksCursor' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\TasksCursor' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\TasksCursor', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\TasksCursor';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\TasksCursor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConnectorTasksAsync
     *
     * List tasks from a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConnectorTasksAsync($connector, $page_size = 15, $cursor = null, string $contentType = self::contentTypes['listConnectorTasks'][0])
    {
        return $this->listConnectorTasksAsyncWithHttpInfo($connector, $page_size, $cursor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConnectorTasksAsyncWithHttpInfo
     *
     * List tasks from a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConnectorTasksAsyncWithHttpInfo($connector, $page_size = 15, $cursor = null, string $contentType = self::contentTypes['listConnectorTasks'][0])
    {
        $returnType = '\Formance\Model\TasksCursor';
        $request = $this->listConnectorTasksRequest($connector, $page_size, $cursor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConnectorTasks'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConnectorTasksRequest($connector, $page_size = 15, $cursor = null, string $contentType = self::contentTypes['listConnectorTasks'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling listConnectorTasks'
            );
        }

        if ($page_size !== null && $page_size > 1000) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling PaymentsApi.listConnectorTasks, must be smaller than or equal to 1000.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling PaymentsApi.listConnectorTasks, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/api/payments/connectors/{connector}/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConnectorsTransfers
     *
     * List transfers and their statuses
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorsTransfers'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\TransfersResponse
     */
    public function listConnectorsTransfers($connector, string $contentType = self::contentTypes['listConnectorsTransfers'][0])
    {
        list($response) = $this->listConnectorsTransfersWithHttpInfo($connector, $contentType);
        return $response;
    }

    /**
     * Operation listConnectorsTransfersWithHttpInfo
     *
     * List transfers and their statuses
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorsTransfers'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\TransfersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConnectorsTransfersWithHttpInfo($connector, string $contentType = self::contentTypes['listConnectorsTransfers'][0])
    {
        $request = $this->listConnectorsTransfersRequest($connector, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\TransfersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\TransfersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\TransfersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\TransfersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\TransfersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConnectorsTransfersAsync
     *
     * List transfers and their statuses
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorsTransfers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConnectorsTransfersAsync($connector, string $contentType = self::contentTypes['listConnectorsTransfers'][0])
    {
        return $this->listConnectorsTransfersAsyncWithHttpInfo($connector, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConnectorsTransfersAsyncWithHttpInfo
     *
     * List transfers and their statuses
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorsTransfers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConnectorsTransfersAsyncWithHttpInfo($connector, string $contentType = self::contentTypes['listConnectorsTransfers'][0])
    {
        $returnType = '\Formance\Model\TransfersResponse';
        $request = $this->listConnectorsTransfersRequest($connector, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConnectorsTransfers'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnectorsTransfers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConnectorsTransfersRequest($connector, string $contentType = self::contentTypes['listConnectorsTransfers'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling listConnectorsTransfers'
            );
        }


        $resourcePath = '/api/payments/connectors/{connector}/transfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPayments
     *
     * List payments
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\PaymentsCursor
     */
    public function listPayments($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        list($response) = $this->listPaymentsWithHttpInfo($page_size, $cursor, $sort, $contentType);
        return $response;
    }

    /**
     * Operation listPaymentsWithHttpInfo
     *
     * List payments
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\PaymentsCursor, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPaymentsWithHttpInfo($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        $request = $this->listPaymentsRequest($page_size, $cursor, $sort, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\PaymentsCursor' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\PaymentsCursor' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\PaymentsCursor', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\PaymentsCursor';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\PaymentsCursor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPaymentsAsync
     *
     * List payments
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentsAsync($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        return $this->listPaymentsAsyncWithHttpInfo($page_size, $cursor, $sort, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPaymentsAsyncWithHttpInfo
     *
     * List payments
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentsAsyncWithHttpInfo($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        $returnType = '\Formance\Model\PaymentsCursor';
        $request = $this->listPaymentsRequest($page_size, $cursor, $sort, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPayments'
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPaymentsRequest($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['listPayments'][0])
    {

        if ($page_size !== null && $page_size > 1000) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling PaymentsApi.listPayments, must be smaller than or equal to 1000.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling PaymentsApi.listPayments, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/api/payments/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentslistAccounts
     *
     * List accounts
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentslistAccounts'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\AccountsCursor
     */
    public function paymentslistAccounts($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['paymentslistAccounts'][0])
    {
        list($response) = $this->paymentslistAccountsWithHttpInfo($page_size, $cursor, $sort, $contentType);
        return $response;
    }

    /**
     * Operation paymentslistAccountsWithHttpInfo
     *
     * List accounts
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentslistAccounts'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\AccountsCursor, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentslistAccountsWithHttpInfo($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['paymentslistAccounts'][0])
    {
        $request = $this->paymentslistAccountsRequest($page_size, $cursor, $sort, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\AccountsCursor' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\AccountsCursor' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\AccountsCursor', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\AccountsCursor';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\AccountsCursor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentslistAccountsAsync
     *
     * List accounts
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentslistAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentslistAccountsAsync($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['paymentslistAccounts'][0])
    {
        return $this->paymentslistAccountsAsyncWithHttpInfo($page_size, $cursor, $sort, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentslistAccountsAsyncWithHttpInfo
     *
     * List accounts
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentslistAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentslistAccountsAsyncWithHttpInfo($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['paymentslistAccounts'][0])
    {
        $returnType = '\Formance\Model\AccountsCursor';
        $request = $this->paymentslistAccountsRequest($page_size, $cursor, $sort, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentslistAccounts'
     *
     * @param  int $page_size The maximum number of results to return per page. (optional, default to 15)
     * @param  string $cursor Parameter used in pagination requests. Maximum page size is set to 15. Set to the value of next for the next page of results. Set to the value of previous for the previous page of results. No other parameters can be set when this parameter is set. (optional)
     * @param  string[] $sort Fields used to sort payments (default is date:desc). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentslistAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentslistAccountsRequest($page_size = 15, $cursor = null, $sort = null, string $contentType = self::contentTypes['paymentslistAccounts'][0])
    {

        if ($page_size !== null && $page_size > 1000) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling PaymentsApi.paymentslistAccounts, must be smaller than or equal to 1000.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling PaymentsApi.paymentslistAccounts, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/api/payments/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readConnectorConfig
     *
     * Read the config of a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readConnectorConfig'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Formance\Model\ConnectorConfigResponse
     */
    public function readConnectorConfig($connector, string $contentType = self::contentTypes['readConnectorConfig'][0])
    {
        list($response) = $this->readConnectorConfigWithHttpInfo($connector, $contentType);
        return $response;
    }

    /**
     * Operation readConnectorConfigWithHttpInfo
     *
     * Read the config of a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readConnectorConfig'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Formance\Model\ConnectorConfigResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function readConnectorConfigWithHttpInfo($connector, string $contentType = self::contentTypes['readConnectorConfig'][0])
    {
        $request = $this->readConnectorConfigRequest($connector, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Formance\Model\ConnectorConfigResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Formance\Model\ConnectorConfigResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Formance\Model\ConnectorConfigResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Formance\Model\ConnectorConfigResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Formance\Model\ConnectorConfigResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readConnectorConfigAsync
     *
     * Read the config of a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readConnectorConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readConnectorConfigAsync($connector, string $contentType = self::contentTypes['readConnectorConfig'][0])
    {
        return $this->readConnectorConfigAsyncWithHttpInfo($connector, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readConnectorConfigAsyncWithHttpInfo
     *
     * Read the config of a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readConnectorConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readConnectorConfigAsyncWithHttpInfo($connector, string $contentType = self::contentTypes['readConnectorConfig'][0])
    {
        $returnType = '\Formance\Model\ConnectorConfigResponse';
        $request = $this->readConnectorConfigRequest($connector, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readConnectorConfig'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readConnectorConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readConnectorConfigRequest($connector, string $contentType = self::contentTypes['readConnectorConfig'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling readConnectorConfig'
            );
        }


        $resourcePath = '/api/payments/connectors/{connector}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetConnector
     *
     * Reset a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetConnector'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resetConnector($connector, string $contentType = self::contentTypes['resetConnector'][0])
    {
        $this->resetConnectorWithHttpInfo($connector, $contentType);
    }

    /**
     * Operation resetConnectorWithHttpInfo
     *
     * Reset a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetConnector'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetConnectorWithHttpInfo($connector, string $contentType = self::contentTypes['resetConnector'][0])
    {
        $request = $this->resetConnectorRequest($connector, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation resetConnectorAsync
     *
     * Reset a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetConnectorAsync($connector, string $contentType = self::contentTypes['resetConnector'][0])
    {
        return $this->resetConnectorAsyncWithHttpInfo($connector, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetConnectorAsyncWithHttpInfo
     *
     * Reset a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetConnectorAsyncWithHttpInfo($connector, string $contentType = self::contentTypes['resetConnector'][0])
    {
        $returnType = '';
        $request = $this->resetConnectorRequest($connector, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetConnector'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resetConnectorRequest($connector, string $contentType = self::contentTypes['resetConnector'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling resetConnector'
            );
        }


        $resourcePath = '/api/payments/connectors/{connector}/reset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uninstallConnector
     *
     * Uninstall a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallConnector'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function uninstallConnector($connector, string $contentType = self::contentTypes['uninstallConnector'][0])
    {
        $this->uninstallConnectorWithHttpInfo($connector, $contentType);
    }

    /**
     * Operation uninstallConnectorWithHttpInfo
     *
     * Uninstall a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallConnector'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function uninstallConnectorWithHttpInfo($connector, string $contentType = self::contentTypes['uninstallConnector'][0])
    {
        $request = $this->uninstallConnectorRequest($connector, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation uninstallConnectorAsync
     *
     * Uninstall a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uninstallConnectorAsync($connector, string $contentType = self::contentTypes['uninstallConnector'][0])
    {
        return $this->uninstallConnectorAsyncWithHttpInfo($connector, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uninstallConnectorAsyncWithHttpInfo
     *
     * Uninstall a connector
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uninstallConnectorAsyncWithHttpInfo($connector, string $contentType = self::contentTypes['uninstallConnector'][0])
    {
        $returnType = '';
        $request = $this->uninstallConnectorRequest($connector, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uninstallConnector'
     *
     * @param  Connector $connector The name of the connector. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uninstallConnectorRequest($connector, string $contentType = self::contentTypes['uninstallConnector'][0])
    {

        // verify the required parameter 'connector' is set
        if ($connector === null || (is_array($connector) && count($connector) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connector when calling uninstallConnector'
            );
        }


        $resourcePath = '/api/payments/connectors/{connector}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($connector !== null) {
            $resourcePath = str_replace(
                '{' . 'connector' . '}',
                ObjectSerializer::toPathValue($connector),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMetadata
     *
     * Update metadata
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  \Formance\Model\PaymentMetadata $payment_metadata payment_metadata (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadata'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateMetadata($payment_id, $payment_metadata, string $contentType = self::contentTypes['updateMetadata'][0])
    {
        $this->updateMetadataWithHttpInfo($payment_id, $payment_metadata, $contentType);
    }

    /**
     * Operation updateMetadataWithHttpInfo
     *
     * Update metadata
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  \Formance\Model\PaymentMetadata $payment_metadata (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadata'] to see the possible values for this operation
     *
     * @throws \Formance\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMetadataWithHttpInfo($payment_id, $payment_metadata, string $contentType = self::contentTypes['updateMetadata'][0])
    {
        $request = $this->updateMetadataRequest($payment_id, $payment_metadata, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateMetadataAsync
     *
     * Update metadata
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  \Formance\Model\PaymentMetadata $payment_metadata (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMetadataAsync($payment_id, $payment_metadata, string $contentType = self::contentTypes['updateMetadata'][0])
    {
        return $this->updateMetadataAsyncWithHttpInfo($payment_id, $payment_metadata, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMetadataAsyncWithHttpInfo
     *
     * Update metadata
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  \Formance\Model\PaymentMetadata $payment_metadata (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMetadataAsyncWithHttpInfo($payment_id, $payment_metadata, string $contentType = self::contentTypes['updateMetadata'][0])
    {
        $returnType = '';
        $request = $this->updateMetadataRequest($payment_id, $payment_metadata, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMetadata'
     *
     * @param  string $payment_id The payment ID. (required)
     * @param  \Formance\Model\PaymentMetadata $payment_metadata (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMetadataRequest($payment_id, $payment_metadata, string $contentType = self::contentTypes['updateMetadata'][0])
    {

        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling updateMetadata'
            );
        }

        // verify the required parameter 'payment_metadata' is set
        if ($payment_metadata === null || (is_array($payment_metadata) && count($payment_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_metadata when calling updateMetadata'
            );
        }


        $resourcePath = '/api/payments/payments/{paymentId}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_metadata)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_metadata));
            } else {
                $httpBody = $payment_metadata;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package types

import (
	"fmt"

	"github.com/ericlagergren/decimal"
)

// Decimal is a wrapper around decimal.Big that allows for JSON marshaling a decimal as a JSON number.
type Decimal struct {
	decimal.Big
}

func (d Decimal) MarshalJSON() ([]byte, error) {
	return []byte(d.String()), nil
}

func (d *Decimal) UnmarshalJSON(p []byte) error {
	if string(p) == "null" {
		return nil
	}

	var z decimal.Big
	_, ok := z.SetString(string(p))
	if !ok {
		return fmt.Errorf("not a valid decimal: %s", p)
	}
	d.Big = z
	return nil
}

// DecimalFromString returns a Decimal from a string
func DecimalFromString(s string) (Decimal, error) {
	d, ok := new(decimal.Big).SetString(s)
	if !ok {
		return Decimal{}, fmt.Errorf("failed to parse string as decimal")
	}

	return Decimal{
		Big: *d,
	}, nil
}

// NewDecimalFromString returns an instance of Decimal from a string
func NewDecimalFromString(s string) (*Decimal, error) {
	d, err := DecimalFromString(s)
	if err != nil {
		return nil, err
	}

	return &d, nil
}

// MustNewDecimalFromString returns an instance of Decimal from a string
// Avoid using this function in production code.
func MustNewDecimalFromString(s string) *Decimal {
	d, err := NewDecimalFromString(s)
	if err != nil {
		panic(err)
	}

	return d
}

// MustDecimalFromString returns an instance of Decimal from a string
// Avoid using this function in production code.
func MustDecimalFromString(s string) Decimal {
	d, err := DecimalFromString(s)
	if err != nil {
		panic(err)
	}

	return d
}
